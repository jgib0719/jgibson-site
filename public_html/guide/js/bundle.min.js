/**
 * CCNA Study Guide Global Configuration
 * SINGLE SOURCE OF TRUTH - All styling, sizing, and layout definitions
 */

const CCNAConfig = {
    // Modal sizing configuration - ALL MODAL DIMENSIONS HERE
    modal: {
        // Modal container classes
        containerClasses: "flex flex-col bg-slate-800 border-2 border-indigo-500/50 rounded-lg shadow-2xl w-full max-w-4xl overflow-hidden transform scale-95 transition-all duration-300 opacity-0",

        // Visual area configuration  
        visualAreaClasses: "w-full flex-shrink-0 flex items-center justify-center p-6",

        // SVG container classes - FORCED STYLING
        svgContainerClasses: "w-full flex items-center justify-center",

        // SVG element classes - FORCED STYLING
        svgClasses: "w-full h-auto max-w-xl block mx-auto",

        // Modal overlay classes
        overlayClasses: "fixed inset-0 bg-black/70 backdrop-blur-sm hidden items-center justify-center p-4 transition-opacity duration-300 opacity-0 z-50",

        // Modal main area classes
        mainAreaClasses: "p-4 md:p-6 relative bg-slate-800",

        // Modal button classes
        closeButtonClasses: "absolute top-3 right-3 text-slate-400 hover:text-white font-semibold py-1 px-3 rounded-lg text-2xl transition-colors",
        titleClasses: "text-2xl font-bold text-slate-100 title-font",
        descriptionClasses: "text-slate-300 mt-3 leading-relaxed",
        markButtonClasses: "flex-1 bg-gradient-to-r from-indigo-500 to-purple-600 text-white py-3 px-4 rounded-md hover:from-indigo-600 hover:to-purple-700 transition-all duration-200 transform hover:scale-105"
    },

    // Details modal configuration
    detailsModal: {
        // Details modal overlay classes
        overlayClasses: "fixed inset-0 bg-black/70 backdrop-blur-sm hidden items-center justify-center p-4 transition-opacity duration-300 opacity-0 z-50",

        // Details modal container classes
        containerClasses: "flex flex-col bg-slate-800 border-2 border-indigo-500/50 rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden transform scale-95 transition-all duration-300 opacity-0",

        // Details modal main area classes
        mainAreaClasses: "p-4 md:p-6 relative bg-slate-800 overflow-y-auto flex-1",

        // Details modal button classes
        closeButtonClasses: "absolute top-3 right-3 text-slate-400 hover:text-white font-semibold py-1 px-3 rounded-lg text-2xl transition-colors",
        titleClasses: "text-2xl font-bold text-slate-100 title-font mb-4",
        bodyClasses: "text-slate-300 leading-relaxed"
    },

    // Quiz history modal configuration
    quizHistoryModal: {
        // Quiz history modal overlay classes
        overlayClasses: "fixed inset-0 bg-black/70 backdrop-blur-sm hidden items-center justify-center p-4 transition-opacity duration-300 opacity-0 z-50",

        // Quiz history modal container classes
        containerClasses: "flex flex-col bg-slate-800 border-2 border-indigo-500/50 rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden transform scale-95 transition-all duration-300 opacity-0",

        // Quiz history modal header classes
        headerClasses: "flex justify-between items-center p-4 md:p-6 border-b border-slate-700",

        // Quiz history modal content classes
        contentClasses: "p-4 md:p-6 overflow-y-auto flex-1",

        // Quiz history modal button classes
        closeButtonClasses: "text-slate-400 hover:text-white font-semibold py-1 px-3 rounded-lg text-2xl transition-colors",
        titleClasses: "text-2xl font-bold text-slate-100 title-font",

        // History list classes
        listClasses: "space-y-4",
        sectionClasses: "bg-slate-700/50 rounded-lg p-4",
        sectionTitleClasses: "text-lg font-semibold text-slate-200 mb-3 border-b border-slate-600 pb-2",
        attemptClasses: "flex justify-between items-center py-2 px-3 bg-slate-800/50 rounded text-sm",
        attemptDateClasses: "text-slate-300",
        attemptScoreClasses: "text-slate-200 font-medium",
        attemptPercentageClasses: "text-indigo-400 font-semibold",
        noAttemptsClasses: "text-slate-400 italic text-center py-4"
    },

    // Topic card configuration
    cards: {
        // Card container classes
        containerClasses: "topic-card relative p-6 flex flex-col justify-center items-center text-center cursor-pointer",

        // Icon classes
        iconClasses: "fas text-5xl text-indigo-400 mb-4",

        // Title classes  
        titleClasses: "text-xl font-semibold text-slate-200 title-font"
    },

    // Layout configuration - CSS handles all classes, JS only handles dynamic inline styles
    layout: {
        // Body styling
        body: {
            textColor: "text-slate-300"
        },

        // Master progress bar (top of page) - only dynamic styles
        masterProgress: {
            barStyles: {
                width: "0%"
            }
        },

        // Page header - keep essential icon and button classes for functionality
        header: {
            iconClasses: "fas fa-gamepad mr-3 text-indigo-500",
            backButtonClasses: "btn btn-secondary btn-sm mt-4",
            backIconClasses: "fas fa-arrow-left mr-2"
        },

        // Section progress bar - only dynamic styles
        sectionProgress: {
            barStyles: {
                width: "0%",
                transition: "width 0.5s ease-in-out"
            }
        },

        // Main content sections - keep grid class for dynamic layout
        section: {
            gridClasses: "topic-grid-container"
        }
    },

    // Progress tracking configuration
    progress: {
        // Total topics will be calculated dynamically from section data files
        // via the section registry system
        dynamicTotals: true
    },

    // UI styling configuration
    ui: {
        // Color scheme
        colors: {
            primary: "#6366f1", // indigo-500
            secondary: "#8b5cf6", // violet-500
            success: "#10b981", // emerald-500
            warning: "#f59e0b", // amber-500
            danger: "#ef4444", // red-500
            background: "#0f172a", // slate-900
            surface: "#1e293b", // slate-800
            border: "#334155" // slate-600
        },

        // Animation settings
        animations: {
            duration: "300ms",
            easing: "cubic-bezier(0.4, 0, 0.2, 1)"
        },

        // Timing configuration - ALL HARDCODED DELAYS
        timing: {
            progressSync: 100, // Progress visual sync delay (ms)
            modalCleanup: 300, // Modal cleanup delay (ms)
            modalOpen: 10, // Modal opening delay (ms)
            modalClose: 300 // Modal closing animation (ms)
        },

        // Text content configuration - ALL HARDCODED TEXT
        text: {
            defaultProgress: "0%", // Default progress percentage display
            defaultProgressDetails: "0 of 30 topics completed",
            sectionLabels: {
                1: "Section 1 Progress"
            }
        },

        // Font configuration
        fonts: {
            primary: "'Rajdhani', sans-serif",
            title: "'Orbitron', sans-serif"
        }
    },

    // CSS styles configuration - ALL EMBEDDED STYLES
    styles: {
        // Body and base styles
        body: {
            fontFamily: "'Rajdhani', sans-serif",
            backgroundColor: "#0f172a",
            color: "#cbd5e1" // text-slate-300
        },

        // Topic card styles
        topicCard: {
            base: {
                backgroundColor: "#1e293b",
                border: "1px solid #334155",
                transition: "transform 0.3s, box-shadow 0.3s",
                boxShadow: "0 4px 6px rgba(0,0,0,0.2), inset 0 0 10px rgba(79,70,229,0.2)"
            },
            hover: {
                transform: "translateY(-5px) scale(1.02)",
                boxShadow: "0 10px 15px rgba(0,0,0,0.3), 0 0 25px rgba(129,140,248,0.4), inset 0 0 15px rgba(79,70,229,0.3)",
                borderColor: "#4f46e5"
            }
        },

        // Modal animation states
        modal: {
            hidden: {
                display: "none",
                opacity: "0"
            },
            visible: {
                display: "flex",
                opacity: "1"
            },
            content: {
                base: {
                    transform: "scale(0.95)",
                    opacity: "0"
                },
                visible: {
                    transform: "scale(1)",
                    opacity: "1"
                }
            },
            visual: {
                background: "radial-gradient(circle, #1e293b, #0f172a)",
                borderBottom: "1px solid #334155"
            }
        },

        // Studied state styles
        studied: {
            position: "relative",
            after: {
                content: "'\\f058'",
                fontFamily: "'Font Awesome 6 Free'",
                fontWeight: "900",
                position: "absolute",
                top: "8px",
                right: "8px",
                color: "#22c55e",
                fontSize: "18px",
                zIndex: "10"
            }
        },

        // Button states for mark completed functionality
        buttonStates: {
            completed: {
                classes: ["bg-slate-600", "hover:bg-slate-700"],
                removeClasses: ["bg-gradient-to-r", "from-indigo-500", "to-purple-600", "hover:from-indigo-600", "hover:to-purple-700"],
                text: '<i class="fas fa-undo mr-2"></i>Mark as Not Studied'
            },
            incomplete: {
                classes: ["bg-gradient-to-r", "from-indigo-500", "to-purple-600", "hover:from-indigo-600", "hover:to-purple-700"],
                removeClasses: ["bg-slate-600", "hover:bg-slate-700"],
                text: '<i class="fas fa-check mr-2"></i>Mark as Studied'
            }
        },

        // Button icon classes
        buttonIcons: {
            check: "fas fa-check mr-2",
            undo: "fas fa-undo mr-2"
        },

        // CSS class constants - ALL HARDCODED CLASSES
        cssClasses: {
            // Modal state classes
            modal: {
                hidden: "hidden",
                visible: "visible"
            },

            // Card state classes
            card: {
                studied: "studied"
            }
        }
    },

    // Section metadata
    // Section data moved to CCNA_SECTION_REGISTRY for single source of truth
    // Dynamic topic counts calculated from actual section data files

    // Helper functions to apply config
    applyModalConfig: function() {
        const modal = document.getElementById('studyModal');
        const modalContent = document.getElementById('modalContent');
        const modalVisual = document.getElementById('modalVisual');
        const modalSvg = document.getElementById('modalSvg');
        const modalMainArea = document.getElementById('modalMainArea');
        const closeModal = document.getElementById('closeModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalDescription = document.getElementById('modalDescription');
        const markCompleted = document.getElementById('markCompleted');

        if (modal) modal.className = this.modal.overlayClasses;
        if (modalContent) modalContent.className = this.modal.containerClasses;
        if (modalVisual) modalVisual.className = this.modal.visualAreaClasses;
        if (modalSvg) modalSvg.className = this.modal.svgContainerClasses;
        if (modalMainArea) modalMainArea.className = this.modal.mainAreaClasses;
        if (closeModal) closeModal.className = this.modal.closeButtonClasses;
        if (modalTitle) modalTitle.className = this.modal.titleClasses;
        if (modalDescription) modalDescription.className = this.modal.descriptionClasses;
        if (markCompleted) markCompleted.className = this.modal.markButtonClasses;
    },

    // Apply details modal configuration to page elements
    applyDetailsModalConfig: function() {
        const detailsModal = document.getElementById('detailsModal');
        const detailsModalContent = document.getElementById('detailsModalContent');
        const detailsModalMain = document.getElementById('detailsModalMain');
        const closeDetails = document.getElementById('closeDetails');
        const detailsModalTitle = document.getElementById('detailsModalTitle');
        const detailsModalBody = document.getElementById('detailsModalBody');

        if (detailsModal) detailsModal.className = this.detailsModal.overlayClasses;
        if (detailsModalContent) detailsModalContent.className = this.detailsModal.containerClasses;
        if (detailsModalMain) detailsModalMain.className = this.detailsModal.mainAreaClasses;
        if (closeDetails) closeDetails.className = this.detailsModal.closeButtonClasses;
        if (detailsModalTitle) detailsModalTitle.className = this.detailsModal.titleClasses;
        if (detailsModalBody) detailsModalBody.className = this.detailsModal.bodyClasses;
    },

    // Apply layout configuration to page elements
    applyLayoutConfig: function() {
        // Only apply essential functional classes and dynamic inline styles
        // CSS file now controls all layout and styling

        // Apply essential icon and button classes for functionality
        const pageIcon = document.getElementById('page-icon');
        const backButton = document.getElementById('back-button');
        const backIcon = document.getElementById('back-icon');

        if (pageIcon) pageIcon.className = this.layout.header.iconClasses;
        if (backButton) backButton.className = this.layout.header.backButtonClasses;
        if (backIcon) backIcon.className = this.layout.header.backIconClasses;

        // Apply dynamic progress bar styles (width must be controlled by JS)
        const masterProgressBar = document.getElementById('progressBar');
        if (masterProgressBar) {
            Object.assign(masterProgressBar.style, this.layout.masterProgress.barStyles);
        }

        const progressBar = document.getElementById('progress-bar');
        if (progressBar) {
            Object.assign(progressBar.style, this.layout.sectionProgress.barStyles);
        }

        // Apply grid classes for dynamic layout
        const sections = document.querySelectorAll('main > section');
        sections.forEach(section => {
            const grid = section.querySelector('[id$="Grid"]');
            if (grid) grid.className = this.layout.section.gridClasses;
        });
    },

    // Function to create topic cards using global config
    createTopicCard: function(topic) {
        const card = document.createElement('div');
        card.className = this.cards.containerClasses + ' cursor-pointer';
        card.setAttribute('data-study-topic', topic.title);
        
        // Use textContent for safety instead of innerHTML for user data
        const iconElement = document.createElement('i');
        iconElement.className = `${topic.icon} ${this.cards.iconClasses}`;
        
        const titleElement = document.createElement('h3');
        titleElement.className = this.cards.titleClasses;
        titleElement.textContent = topic.title; // Safe text content
        
        card.appendChild(iconElement);
        card.appendChild(titleElement);
        
        return card;
    },

    // Apply button state styling programmatically
    applyButtonState: function(button, isCompleted) {
        if (!button) return;
        
        const state = isCompleted ? this.styles.buttonStates.completed : this.styles.buttonStates.incomplete;
        const oppositeState = isCompleted ? this.styles.buttonStates.incomplete : this.styles.buttonStates.completed;

        // Remove opposite state classes
        button.classList.remove(...oppositeState.classes);

        // Add current state classes (avoid duplicates)
        state.classes.forEach(cls => {
            if (!button.classList.contains(cls)) {
                button.classList.add(cls);
            }
        });

        // Update button text safely using DOM manipulation
        button.innerHTML = ''; // Clear existing content
        const icon = document.createElement('i');
        icon.className = isCompleted ? 'fas fa-undo mr-2' : 'fas fa-check mr-2';
        const text = document.createTextNode(isCompleted ? 'Mark as Not Studied' : 'Mark as Studied');
        button.appendChild(icon);
        button.appendChild(text);
    },

    // Initialize button with default state
    initializeButton: function(button, isCompleted = false) {
        if (!button) return;
        
        // Start with base button classes (without background colors)
        const baseClasses = "flex-1 text-white py-3 px-4 rounded-md transition-all duration-200 transform hover:scale-105";
        
        const state = isCompleted ? this.styles.buttonStates.completed : this.styles.buttonStates.incomplete;
        
        // Set all classes at once
        button.className = baseClasses + ' ' + state.classes.join(' ');
        
        // Set button content safely using DOM manipulation
        button.innerHTML = ''; // Clear existing content
        const icon = document.createElement('i');
        icon.className = isCompleted ? 'fas fa-undo mr-2' : 'fas fa-check mr-2';
        const text = document.createTextNode(isCompleted ? 'Mark as Not Studied' : 'Mark as Studied');
        button.appendChild(icon);
        button.appendChild(text);
    },

    // Initialize all styling (call this after DOM is loaded)
    initializeGlobalStyling: function() {
        this.applyModalConfig();
        this.applyDetailsModalConfig();
        this.applyLayoutConfig();
        this.initializeTextContent();

        // Initialize mark completed button with default state
        const markButton = document.getElementById('markCompleted');
        if (markButton) {
            this.initializeButton(markButton, false);
        }
    },

    // Initialize default text content from global config
    initializeTextContent: function() {
        // Initialize progress text elements
        const progressText = document.getElementById('progressText');
        const sectionProgressText = document.getElementById('progress-text');

        if (progressText) progressText.textContent = this.ui.text.defaultProgress;
        if (sectionProgressText) sectionProgressText.textContent = this.ui.text.defaultProgress;
    },

    // Modal state management functions
    openModal: function(modal, content) {
        modal.classList.remove(this.styles.cssClasses.modal.hidden);
        setTimeout(() => {
            modal.classList.add(this.styles.cssClasses.modal.visible);
            content.classList.add(this.styles.cssClasses.modal.visible);

            // Apply SVG styling after content is inserted
            this.applySvgStyling();
        }, this.ui.timing.modalOpen);
    },

    applySvgStyling: function() {
        // Apply styling to all SVG elements in the modal
        const modalSvg = document.getElementById('modalSvg');
        if (modalSvg) {
            const svgElements = modalSvg.querySelectorAll('svg');
            console.log('Found', svgElements.length, 'SVG elements to style');
            svgElements.forEach((svg, index) => {
                console.log('Styling SVG', index, svg);
                // Apply CSS class for styling instead of inline styles (CSP compliance)
                svg.className = this.modal.svgClasses + ' modal-svg-styled';
            });
        } else {
            console.log('modalSvg container not found');
        }
    },

    closeModal: function(modal, content) {
        modal.classList.remove(this.styles.cssClasses.modal.visible);
        content.classList.remove(this.styles.cssClasses.modal.visible);
        setTimeout(() => {
            modal.classList.add(this.styles.cssClasses.modal.hidden);
        }, this.ui.timing.modalClose);
    },

    // Details modal functions
    openDetailsModal: function(modal, content) {
        modal.classList.remove(this.styles.cssClasses.modal.hidden);
        setTimeout(() => {
            modal.classList.add(this.styles.cssClasses.modal.visible);
            content.classList.add(this.styles.cssClasses.modal.visible);
        }, this.ui.timing.modalOpen);
    },

    closeDetailsModal: function(modal, content) {
        modal.classList.remove(this.styles.cssClasses.modal.visible);
        content.classList.remove(this.styles.cssClasses.modal.visible);
        setTimeout(() => {
            modal.classList.add(this.styles.cssClasses.modal.hidden);
        }, this.ui.timing.modalClose);
    },

    loadDetailsContent: function(sectionNumber, topicTitle) {
        // Get the details data for the current section
        const detailsData = window[`SECTION${sectionNumber}_DETAILS`];
        if (detailsData && detailsData[topicTitle]) {
            return detailsData[topicTitle];
        }
        return `<p>Details not available for this topic yet.</p>`;
    },

    isModalVisible: function(modal) {
        return modal.classList.contains(this.styles.cssClasses.modal.visible);
    },

    // Card state management functions
    markCardAsStudied: function(cardElement, isStudied) {
        if (isStudied) {
            cardElement.classList.add(this.styles.cssClasses.card.studied);
        } else {
            cardElement.classList.remove(this.styles.cssClasses.card.studied);
        }
    },

    // CENTRALIZED QUIZ CONFIGURATION
    quiz: {
        // Element IDs - centralize all DOM element selectors
        elementIds: {
            quizContainer: 'quiz-container',
            resultsContainer: 'results-container',
            setupContainer: 'setup-container',
            loadingContainer: 'loading-container',
            questionArea: 'question-area',
            feedbackArea: 'feedback-area',
            scoreEl: 'score',
            finalScoreEl: 'final-score',
            progressBar: 'progress-bar',
            nextBtn: 'next-btn',
            restartBtn: 'restart-btn',
            homeBtn: 'home-btn',
            bestScore: 'best-score',
            history: 'history',
            beginBtn: 'begin-btn',
            resumeBtn: 'resume-btn',
            ciscoEntryBtn: 'cisco-entry-btn',
            wileyEntryBtn: 'wiley-entry-btn',
            enterContainer: 'enter-container',
            optionsContainer: 'options-container',
            submitMultiBtn: 'submit-multi-btn',
            resultBest: 'result-best',
            historyBtn: 'history-btn',
            quizHistoryModal: 'quiz-history-modal',
            quizHistoryCloseBtn: 'quiz-history-close-btn',
            quizHistoryContent: 'quiz-history-content',
            backToSetupBtn: 'back-to-setup-btn',
            backToCategoryBtn: 'back-to-category-btn'
        },

        // CSS Classes - centralize all class names used in JavaScript
        cssClasses: {
            // State classes
            states: {
                hidden: 'hidden',
                visible: 'visible'
            },

            // Feedback classes
            feedback: {
                correct: {
                    background: 'bg-green-100',
                    border: 'border-green-300',
                    text: 'text-green-800'
                },
                incorrect: {
                    background: 'bg-red-100',
                    border: 'border-red-300',
                    text: 'text-red-800'
                }
            },

            // Button classes
            buttons: {
                option: 'option-btn',
                optionLabel: 'option-label',
                submit: 'submit-btn-ready',
                submitDisabled: 'submit-btn-disabled',
                submitReady: 'submit-btn-ready',
                sizeSelected: 'size-selected',
                selectedMultiple: 'option-btn selected'
            },

            // Text classes
            text: {
                questionNumber: 'text-sm text-gray-600 mb-2',
                questionTitle: 'text-xl font-semibold text-gray-900 mb-4'
            },

            // Legacy classes for backward compatibility
            hidden: 'hidden',
            correct: 'correct',
            incorrect: 'incorrect',
            visible: 'visible',
            optionBtn: 'option-btn',
            sizeBtn: 'size-btn',

            // State classes (legacy)
            selected: 'bg-blue-100 border-blue-500',
            unselected: 'bg-white border-gray-300',

            // Feedback classes (legacy)
            correctFeedback: 'bg-green-100 border-green-300 text-green-800',
            incorrectFeedback: 'bg-red-100 border-red-300 text-red-800',
            neutralFeedback: 'bg-slate-100 border-slate-300 text-slate-800',

            // Button classes (legacy)
            primaryBtn: 'primary-btn',
            secondaryBtn: 'secondary-btn',
            successBtn: 'success-btn',
            submitBtn: 'bg-green-500 text-white font-bold py-2 px-4 rounded-lg mt-4 shadow hover:bg-green-600 transition',

            // Layout classes (legacy)
            loading: 'loading-container',
            questionContainer: 'question-area'
        },

        // Colors - centralize all color values
        colors: {
            primary: '#4f46e5',
            secondary: '#6366f1',
            success: '#10b981',
            danger: '#ef4444',
            warning: '#f59e0b',

            // Background colors
            slate900: '#0f172a',
            slate800: '#1e293b',
            slate700: '#334155',
            slate600: '#475569',
            slate500: '#64748b',
            slate400: '#94a3b8',
            slate300: '#cbd5e1',
            slate200: '#e2e8f0',

            // Text colors
            white: '#ffffff',
            textPrimary: '#e2e8f0',
            textSecondary: '#94a3b8',
            textMuted: '#64748b',

            // Quiz specific colors
            correctGreen: '#10B981',
            incorrectRed: '#EF4444',
            loadingSpinner: '#4f46e5'
        },

        // Animation and timing constants
        animations: {
            // Durations in milliseconds
            fastTransition: 150,
            normalTransition: 300,
            slowTransition: 500,

            // Specific animation timings
            spinDuration: '1s',
            fadeInDuration: '300ms',
            slideInDuration: '200ms',

            // Animation types
            spinAnimation: 'spin 1s linear infinite',
            fadeInAnimation: 'fadeIn 300ms ease-in-out',
            slideInAnimation: 'slideIn 200ms ease-out',

            // Transition styles
            allTransition: 'all 0.15s ease-in-out',
            opacityTransition: 'opacity 0.15s ease-in-out',
            colorTransition: 'background-color 0.15s ease-in-out',
            scaleTransition: 'transform 0.2s ease-in-out'
        },

        // Quiz behavior constants
        behavior: {
            defaultQuizSize: 20,
            maxHistoryEntries: 50,
            maxRecentAttempts: 10,
            loadingDelay: 250, // milliseconds
            feedbackDisplayTime: 500, // milliseconds before showing results

            // Storage keys
            storageKeys: {
                history: 'history',
                best: 'best',
                save: 'save'
            },

            // API endpoints
            endpoints: {
                ciscoQuestions: '/v1/questions?category=cisco',
                wileyQuestions: '/v1/questions?category=wiley'
            }
        },

        // Text content constants for UI elements
        textContent: {
            feedback: {
                correct: 'Correct!',
                incorrect: 'Incorrect.'
            },
            buttons: {
                submitAnswer: 'Submit Answer',
                nextQuestion: 'Next Question',
                startQuiz: 'Start Quiz',
                restartQuiz: 'Restart Quiz',
                resumeQuiz: 'Resume Saved Quiz',
                home: 'Home'
            },
            messages: {
                noHighScores: 'No high scores yet. Take a quiz!',
                noPastAttempts: 'No past attempts recorded.',
                loadingQuiz: 'Loading Quiz...',
                quizComplete: 'Quiz Complete!',
                failedToLoad: 'Failed to load quiz questions. Please try again later.',
                savedQuizMissing: 'Saved quiz could not be restored. Questions missing.'
            }
        },

        // Text content constants
        text: {
            // Messages
            noHighScores: 'No high scores yet. Take a quiz!',
            noPastAttempts: 'No past attempts recorded.',
            loadingQuiz: 'Loading Quiz...',
            quizComplete: 'Quiz Complete!',
            yourFinalScore: 'Your final score is:',
            correctHeading: 'Correct!',
            incorrectHeading: 'Incorrect.',
            partialCreditHeading: 'Partially Correct ({pct}% credit)',

            // Labels  
            questionLabel: 'Question {current} of {total}',
            questionIdLabel: 'ID: {id}',
            scoreLabel: 'Score: {score} / {total}',
            bestForSizeLabel: 'Best for this size: {score}/{total} ({pct}%) — {date}',
            allTimeBestLabel: 'All-time best: {score}/{total} ({pct}%) — {date} (size: {size})',
            pastAttemptsLabel: 'Past Attempts',

            // Button text
            nextQuestion: 'Next Question',
            submitAnswer: 'Submit Answer',
            startQuiz: 'Start Quiz',
            restartQuiz: 'Restart Quiz',
            resumeQuiz: 'Resume Saved Quiz',
            home: 'Home',

            // Error messages
            failedToLoad: 'Failed to load quiz questions. Please try again later.',
            savedQuizMissing: 'Saved quiz could not be restored. Questions missing.',

            // Accessibility
            explanationLabel: 'Explanation:',
            questionImageAlt: 'Question Image'
        },

        // Image handling
        images: {
            // Fallback logic for images
            fallbackExtensions: ['png', 'svg', 'jpeg', 'jpg'],
            errorHandler: "if(this.dataset.altAttempt==='1'){this.onerror=null;this.replaceWith(document.createElement('div'));}else{this.dataset.altAttempt='1';if(this.src.endsWith('.png')){this.src=this.src.replace('.png','.svg');}else if(this.src.endsWith('.svg')){this.src=this.src.replace('.svg','.png');} }",

            // Image styling
            containerClass: 'mb-4',
            imageClass: 'max-w-full rounded shadow'
        }
    },

    // SITE-WIDE CONSTANTS
    site: {
        // Brand colors that appear throughout the site
        brandColors: {
            cisco: 'linear-gradient(90deg, #0097D6 0%, #007CBF 100%)',
            wiley: 'linear-gradient(90deg, #FF8C00 0%, #D36B00 100%)',
            primary: 'linear-gradient(to bottom right, #6366f1, #8b5cf6)',
            secondary: 'linear-gradient(135deg, #667eea, #764ba2)'
        },

        // Font families
        fonts: {
            primary: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
            heading: "'Orbitron', monospace",
            mono: "'Fira Code', 'Courier New', monospace"
        },

        // Breakpoints (matching CSS media queries)
        breakpoints: {
            sm: '640px',
            md: '768px',
            lg: '1024px',
            xl: '1280px'
        },

        // Common spacing values
        spacing: {
            xs: '0.25rem',
            sm: '0.5rem',
            md: '1rem',
            lg: '1.5rem',
            xl: '2rem',
            xxl: '3rem'
        }
    }
}; // End of CCNAConfig object

// Utility functions for using the configuration
const Config = {
    // Get element by configured ID
    getElement: (key) => document.getElementById(CCNAConfig.quiz.elementIds[key]),

    // Get multiple elements by configured selectors
    getElements: (selector) => document.querySelectorAll(selector),

    // Apply CSS classes from config
    addClass: (element, classKey) => {
        const className = CCNAConfig.quiz.cssClasses[classKey];
        if (className) element.classList.add(...className.split(" "));
    },

    removeClass: (element, classKey) => {
        const className = CCNAConfig.quiz.cssClasses[classKey];
        if (className) element.classList.remove(...className.split(" "));
    },

    toggleClass: (element, classKey) => {
        const className = CCNAConfig.quiz.cssClasses[classKey];
        if (className) {
            className.split(" ").forEach(cls => element.classList.toggle(cls));
        }
    },

    // Get color values
    getColor: (colorKey) => CCNAConfig.quiz.colors[colorKey] || CCNAConfig.site.brandColors[colorKey],

    // Get text with placeholder replacement
    getText: (textKey, placeholders = {}) => {
        let text = CCNAConfig.quiz.text[textKey] || textKey;
        Object.keys(placeholders).forEach(key => {
            text = text.replace(new RegExp(`\\{${key}\\}`, "g"), placeholders[key]);
        });
        return text;
    },

    // Get animation styles
    getAnimation: (animKey) => CCNAConfig.quiz.animations[animKey],

    // Get behavior constants
    getBehavior: (behaviorKey) => CCNAConfig.quiz.behavior[behaviorKey]
};

// Export for global use
if (typeof window !== 'undefined') {
    window.CCNAConfig = CCNAConfig;
    window.Config = Config;
}/**
 * Security Utilities for CCNA Quiz Application
 * Provides XSS protection, input sanitization, and security helpers
 */

class CCNASecurityUtils {
    static instance = null;

    constructor() {
        if (CCNASecurityUtils.instance) {
            return CCNASecurityUtils.instance;
        }

        // Initialize DOMPurify if available, otherwise use fallback
        this.domPurify = window.DOMPurify || null;
        this.initializeFallbackSanitizer();

        CCNASecurityUtils.instance = this;
    }

    /**
     * Initialize fallback HTML sanitizer for environments without DOMPurify
     */
    initializeFallbackSanitizer() {
        if (!this.domPurify) {
            this.fallbackSanitizer = {
                // Basic HTML entities that need escaping
                htmlEntities: {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#x27;',
                    '/': '&#x2F;'
                },

                // Allowed HTML tags for content (very restrictive)
                allowedTags: new Set(['b', 'i', 'em', 'strong', 'code', 'pre', 'br']),

                // Allowed attributes (minimal set)
                allowedAttributes: new Set(['class'])
            };
        }
    }

    /**
     * Sanitize HTML content to prevent XSS attacks
     * @param {string} html - HTML content to sanitize
     * @param {object} options - Sanitization options
     * @returns {string} Sanitized HTML content
     */
    sanitizeHTML(html, options = {}) {
        if (typeof html !== 'string') {
            return '';
        }

        const config = {
            ALLOWED_TAGS: options.allowedTags || ['b', 'i', 'em', 'strong', 'code', 'pre', 'br', 'p', 'div', 'span', 'button', 'h1', 'h2', 'h3'],
            ALLOWED_ATTR: options.allowedAttributes || ['class', 'id', 'data-answer', 'data-question-image'],
            ALLOW_DATA_ATTR: false,
            FORBID_SCRIPT: true,
            FORBID_TAGS: ['script', 'object', 'embed', 'form', 'input', 'textarea'],
            FORBID_ATTR: ['onclick', 'onload', 'onerror', 'onfocus', 'onblur', 'style'],
            ...options
        };

        if (this.domPurify) {
            return this.domPurify.sanitize(html, config);
        } else {
            return this.fallbackSanitize(html, config);
        }
    }

    /**
     * Fallback HTML sanitization when DOMPurify is not available
     * @param {string} html - HTML to sanitize
     * @param {object} config - Sanitization configuration
     * @returns {string} Sanitized HTML
     */
    fallbackSanitize(html, config) {
        // For quiz content, we need to be less aggressive to allow UI elements
        // First, remove dangerous scripts and handlers
        let sanitized = html
            .replace(/<script[^>]*>.*?<\/script>/gi, '')
            .replace(/\son\w+\s*=/gi, '') // More specific: space + on + word + equals (event handlers)
            .replace(/javascript:/gi, '')
            .replace(/<iframe[^>]*>.*?<\/iframe>/gi, '')
            .replace(/<object[^>]*>.*?<\/object>/gi, '')
            .replace(/<embed[^>]*>.*?<\/embed>/gi, '');

        // For quiz UI, we need to allow more tags but still be security-conscious
        const allowedTags = config.ALLOWED_TAGS || ['p', 'div', 'span', 'button', 'h1', 'h2', 'h3', 'b', 'i', 'em', 'strong', 'code', 'pre', 'br'];
        const allowedAttributes = config.ALLOWED_ATTR || ['class', 'id', 'data-answer', 'data-question-image'];

        // More specific validation: check for remaining script injection attempts
        if (sanitized.includes('<script') || sanitized.includes('javascript:') || /\son\w+\s*=/.test(sanitized)) {
            console.warn('SECURITY DEBUG: Potentially dangerous HTML detected after initial cleanup, applying aggressive sanitization');
            // Fall back to aggressive escaping if dangerous patterns persist
            return html.replace(/[&<>"'\/]/g, (char) => {
                return this.fallbackSanitizer.htmlEntities[char] || char;
            });
        }

        return sanitized;
    }

    /**
     * Escape HTML entities in text content
     * @param {string} text - Text to escape
     * @returns {string} Escaped text
     */
    escapeHTML(text) {
        if (typeof text !== 'string') {
            return '';
        }

        return text.replace(/[&<>"'\/]/g, (char) => {
            const entities = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '/': '&#x2F;'
            };
            return entities[char] || char;
        });
    }

    /**
     * Safely set innerHTML with automatic sanitization
     * @param {HTMLElement} element - Element to set content on
     * @param {string} html - HTML content to set
     * @param {object} options - Sanitization options
     */
    safeSetHTML(element, html, options = {}) {
            if (!element || typeof element.innerHTML === 'undefined') {
                console.warn('Invalid element provided to safeSetHTML');
                return;
            }

            const sanitizedHTML = this.sanitizeHTML(html, options);
            element.innerHTML = sanitizedHTML;
        }
        /**
         * Safely set text content (always escaped)
         * @param {HTMLElement} element - Element to set content on
         * @param {string} text - Text content to set
         */
    safeSetText(element, text) {
        if (!element) {
            console.warn('Invalid element provided to safeSetText');
            return;
        }

        if (element.textContent !== undefined) {
            element.textContent = text || '';
        } else {
            // Fallback for older browsers
            element.innerText = text || '';
        }
    }

    /**
     * Create a safe DOM element with sanitized content
     * @param {string} tagName - HTML tag name
     * @param {object} attributes - Element attributes
     * @param {string} content - Element content (will be sanitized)
     * @param {boolean} isHTML - Whether content should be treated as HTML or text
     * @returns {HTMLElement} Created element
     */
    createElement(tagName, attributes = {}, content = '', isHTML = false) {
        const element = document.createElement(tagName);

        // Set attributes safely
        Object.entries(attributes).forEach(([key, value]) => {
            // Only allow safe attributes
            const safeAttributes = ['class', 'id', 'data-*', 'aria-*', 'role', 'tabindex'];
            const isSafe = safeAttributes.some(safe =>
                safe.endsWith('*') ? key.startsWith(safe.slice(0, -1)) : key === safe
            );

            if (isSafe && typeof value === 'string') {
                element.setAttribute(key, value);
            }
        });

        // Set content safely
        if (content) {
            if (isHTML) {
                this.safeSetHTML(element, content);
            } else {
                this.safeSetText(element, content);
            }
        }

        return element;
    }

    /**
     * Validate and sanitize URL for safe usage
     * @param {string} url - URL to validate
     * @param {array} allowedProtocols - Allowed URL protocols
     * @returns {string|null} Sanitized URL or null if invalid
     */
    sanitizeURL(url, allowedProtocols = ['http:', 'https:', 'mailto:']) {
        if (typeof url !== 'string' || !url.trim()) {
            return null;
        }

        try {
            const urlObj = new URL(url);

            if (allowedProtocols.includes(urlObj.protocol)) {
                return urlObj.toString();
            } else {
                console.warn(`Blocked URL with disallowed protocol: ${urlObj.protocol}`);
                return null;
            }
        } catch (e) {
            // Invalid URL
            console.warn('Invalid URL provided:', url);
            return null;
        }
    }

    /**
     * Generate Content Security Policy nonce for inline scripts
     * @returns {string} CSP nonce value
     */
    generateCSPNonce() {
        if (crypto && crypto.getRandomValues) {
            const array = new Uint8Array(16);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode.apply(null, array));
        } else {
            // Fallback for environments without crypto
            return btoa(Math.random().toString(36).substr(2, 16));
        }
    }

    /**
     * Check if content contains potential XSS patterns
     * @param {string} content - Content to check
     * @returns {object} Analysis result with warnings
     */
    analyzeForXSS(content) {
        const analysis = {
            isSafe: true,
            warnings: [],
            blocked: []
        };

        if (typeof content !== 'string') {
            return analysis;
        }

        // Common XSS patterns to detect
        const xssPatterns = [
            { pattern: /<script[^>]*>/i, description: 'Script tag detected' },
            { pattern: /javascript:/i, description: 'JavaScript protocol detected' },
            { pattern: /on\w+\s*=/i, description: 'Inline event handler detected' },
            { pattern: /<iframe[^>]*>/i, description: 'Iframe tag detected' },
            { pattern: /<object[^>]*>/i, description: 'Object tag detected' },
            { pattern: /<embed[^>]*>/i, description: 'Embed tag detected' },
            { pattern: /data:text\/html/i, description: 'Data URL with HTML detected' },
            { pattern: /vbscript:/i, description: 'VBScript protocol detected' }
        ];

        xssPatterns.forEach(({ pattern, description }) => {
            if (pattern.test(content)) {
                analysis.isSafe = false;
                analysis.warnings.push(description);
                analysis.blocked.push(pattern.toString());
            }
        });

        return analysis;
    }

    /**
     * Strip inline styles from HTML and replace with CSS classes for CSP compliance
     * @param {string} html - HTML content with inline styles
     * @returns {string} HTML content with CSS classes instead of inline styles
     */
    stripInlineStylesForModal(html) {
        if (typeof html !== 'string') {
            return '';
        }

        let cleanedHtml = html;

        // Replace div with inline styles with modal-content wrapper
        cleanedHtml = cleanedHtml.replace(
            /<div style="font-family: 'Inter', sans-serif; color: #E0E0E0;">/g,
            '<div class="modal-content">'
        );

        // Replace h3 with inline styles - preserve semantic color coding
        cleanedHtml = cleanedHtml.replace(
            /<h3 style="color: #00A8FF; border-bottom: 2px solid #00A8FF; padding-bottom: 5px;">/g,
            '<h3 class="topic-primary">'
        ).replace(
            /<h3 style="color: #2ECC71; border-bottom: 2px solid #2ECC71; padding-bottom: 5px;">/g,
            '<h3 class="topic-implementation">'
        ).replace(
            /<h3 style="color: #F39C12; border-bottom: 2px solid #F39C12; padding-bottom: 5px;">/g,
            '<h3 class="topic-workflow">'
        );

        // Replace h4 with inline styles - preserve semantic color coding
        cleanedHtml = cleanedHtml.replace(
            /<h4 style="color: #58D4FF;">/g,
            '<h4 class="section-overview">'
        ).replace(
            /<h4 style="color: #58D68D;">/g,
            '<h4 class="section-technical">'
        ).replace(
            /<h4 style="color: #F5B041;">/g,
            '<h4 class="section-process">'
        ).replace(
            /<h4 style="color: #00CFFF;">/g,
            '<h4 class="section-default">'
        );

        // Replace h5 with inline styles - preserve semantic meaning
        cleanedHtml = cleanedHtml.replace(
            /<h5 style="color: #00CFFF; margin-bottom: 5px;">/g,
            '<h5 class="meta-info">'
        ).replace(
            /<h5 style="color: #58D68D; margin-top: 0;">/g,
            '<h5 class="meta-technical-alt">'
        ).replace(
            /<h5 style="color: #58D68D; margin-bottom: 8px;">/g,
            '<h5 class="meta-technical">'
        ).replace(
            /<h5 style="color: #58D68D; margin-bottom: 5px;">/g,
            '<h5 class="meta-technical">'
        );

        // Fallback: Remove any remaining header styles that don't match known patterns
        cleanedHtml = cleanedHtml.replace(
            /<(h[3-5]) style="[^"]*">/g,
            '<$1>'
        );

        // Replace ol with inline styles
        cleanedHtml = cleanedHtml.replace(
            /<ol style="margin-left: 20px;">/g,
            '<ol>'
        );

        // Replace ul with inline styles
        cleanedHtml = cleanedHtml.replace(
            /<ul style="list-style-type: square; margin-left: 20px;">/g,
            '<ul>'
        );

        // Replace study resources div
        cleanedHtml = cleanedHtml.replace(
            /<div style="margin-top: 20px; padding: 10px; border-top: 1px solid #444;">/g,
            '<div class="study-resources">'
        );

        // Replace em with font-size
        cleanedHtml = cleanedHtml.replace(
            /<em style="font-size: 0\.9em;">/g,
            '<em>'
        );

        // Replace links with color
        cleanedHtml = cleanedHtml.replace(
            /<a href="([^"]*)" target="_blank" style="color: #66B2FF;">/g,
            '<a href="$1" target="_blank">'
        );

        // Replace pre and code elements for command examples
        cleanedHtml = cleanedHtml.replace(
            /<pre style="background-color: #2D2D2D; padding: 15px; border-radius: 8px; border: 1px solid #444; font-size: 0\.9em;">/g,
            '<pre class="command-pre">'
        );

        cleanedHtml = cleanedHtml.replace(
            /<code style="color: #9CDCFE;">/g,
            '<code class="command-code">'
        );

        // Replace table styles
        cleanedHtml = cleanedHtml.replace(
            /<table style="border-collapse: collapse; width: 100%; margin: 10px 0;">/g,
            '<table>'
        );

        // Replace th styles
        cleanedHtml = cleanedHtml.replace(
            /<th style="border: 1px solid #4B5563; padding: 8px; color: #F3F4F6;">/g,
            '<th>'
        );

        // Replace tr with background colors
        cleanedHtml = cleanedHtml.replace(
            /<tr style="background-color: #374151;">/g,
            '<tr class="table-row-medium">'
        ).replace(
            /<tr style="background-color: #1F2937;">/g,
            '<tr class="table-row-dark">'
        ).replace(
            /<tr style="background-color: #2a2a2a;">/g,
            '<tr class="table-row-alt">'
        ).replace(
            /<tr style="background-color: #1e1e1e;">/g,
            '<tr class="table-row-darker">'
        );

        // Replace special content boxes
        cleanedHtml = cleanedHtml.replace(
            /<div style="background-color: #1a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #00A8FF;">/g,
            '<div class="info-box">'
        ).replace(
            /<div style="background-color: #1a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #2ECC71;">/g,
            '<div class="success-box">'
        ).replace(
            /<div style="background-color: #1a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #F39C12;">/g,
            '<div class="warning-box-alt">'
        ).replace(
            /<div style="background-color: #2d2d2d; padding: 15px; border-radius: 8px; border: 1px solid #444; margin: 10px 0;">/g,
            '<div class="code-block">'
        );

        // Replace additional pre elements
        cleanedHtml = cleanedHtml.replace(
            /<pre style="background-color: #1a1a1a; padding: 10px; border-radius: 5px; font-size: 0\.9em;">/g,
            '<pre class="code-block-dark">'
        );

        // Replace td styles with various combinations
        cleanedHtml = cleanedHtml.replace(
            /<td style="border: 1px solid #4B5563; padding: 8px; font-weight: bold;">/g,
            '<td class="table-cell-bold">'
        ).replace(
            /<td style="border: 1px solid #4B5563; padding: 8px; color: #22c55e;">/g,
            '<td class="table-cell-success">'
        ).replace(
            /<td style="border: 1px solid #4B5563; padding: 8px; color: #fbbf24;">/g,
            '<td class="table-cell-warning">'
        ).replace(
            /<td style="border: 1px solid #4B5563; padding: 8px; color: #60a5fa;">/g,
            '<td class="table-cell-info">'
        ).replace(
            /<td style="border: 1px solid #4B5563; padding: 8px[^"]*">/g,
            '<td>'
        );

        // Remove any remaining style attributes
        cleanedHtml = cleanedHtml.replace(/\s+style="[^"]*"/g, '');

        return cleanedHtml;
    }
}

// Create singleton instance and expose globally
window.CCNASecurityUtils = CCNASecurityUtils;
window.securityUtils = new CCNASecurityUtils();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CCNASecurityUtils;
}/**
 * CCNA Section Topic Totals Registry
 * Centralized registry for section topic counts
 * Section data files call this when they are loaded independently  
 * This allows the progress tracker to get accurate counts without loading full section data
 */

const CCNA_SECTION_REGISTRY = {
    /**
     * Section topic totals - dynamically calculated from section data files
     * This registry provides a lightweight way to get topic counts
     */
    topicTotals: {},  // Will be populated dynamically as section data loads

    /**
     * Register section data and calculate topic totals dynamically
     * Called by each section data file when it loads
     */
    registerSectionData: function(sectionNumber, sectionData) {
        if (sectionData && sectionData.metadata && typeof sectionData.metadata.totalTopics !== 'undefined') {
            // Use the section's own totalTopics calculation
            if (typeof sectionData.metadata.totalTopics === 'function') {
                this.topicTotals[sectionNumber] = sectionData.metadata.totalTopics();
            } else {
                this.topicTotals[sectionNumber] = sectionData.metadata.totalTopics;
            }
        }
        console.log(`Registered section ${sectionNumber} with ${this.topicTotals[sectionNumber]} topics`);
    },

    /**
     * Get total topics for a specific section
     */
    getTopicTotal: function(sectionNumber) {
        return this.topicTotals[sectionNumber] || 0;
    },

    /**
     * Get total topics across all sections
     */
    getTotalTopics: function() {
        return Object.values(this.topicTotals).reduce((total, count) => total + count, 0);
    },

    /**
     * Update topic total for a specific section (called when section data changes)
     */
    updateTopicTotal: function(sectionNumber, totalTopics) {
        this.topicTotals[sectionNumber] = totalTopics;
        // Dispatch event for progress trackers to update
        window.dispatchEvent(new CustomEvent('topicCountsUpdated', {
            detail: { sectionNumber, totalTopics, allTotals: this.topicTotals }
        }));
    },

    /**
     * Section metadata for display purposes
     */
    sectionInfo: {
        1: {
            title: "Network Fundamentals",
            shortTitle: "Fundamentals",
            color: "#4f46e5",
            icon: "fa-network-wired"
        },
        2: {
            title: "Network Access",
            shortTitle: "Access", 
            color: "#7c3aed",
            icon: "fa-ethernet"
        },
        3: {
            title: "IP Connectivity",
            shortTitle: "Connectivity",
            color: "#2563eb",
            icon: "fa-route"
        },
        4: {
            title: "IP Services",
            shortTitle: "Services",
            color: "#dc2626",
            icon: "fa-server"
        },
        5: {
            title: "Security Fundamentals", 
            shortTitle: "Security",
            color: "#ea580c",
            icon: "fa-shield-alt"
        },
        6: {
            title: "Network Automation & Programmability",
            shortTitle: "Automation",
            color: "#16a34a",
            icon: "fa-code"
        }
    },

    /**
     * Get topic total for a specific section
     */
    getTopicTotal(sectionNumber) {
        return this.topicTotals[sectionNumber] || 0;
    },

    /**
     * Get all topic totals
     */
    getAllTopicTotals() {
        return { ...this.topicTotals };
    },

    /**
     * Get total topics across all sections
     */
    getTotalTopics() {
        return Object.values(this.topicTotals).reduce((total, count) => total + count, 0);
    },

    /**
     * Get section information
     */
    getSectionInfo(sectionNumber) {
        return this.sectionInfo[sectionNumber] || null;
    },

    /**
     * Get all section information
     */
    getAllSectionInfo() {
        return { ...this.sectionInfo };
    },

    /**
     * Update topic total for a specific section
     */
    updateTopicTotal(sectionNumber, totalTopics) {
        if (typeof sectionNumber === 'number' && typeof totalTopics === 'number' && totalTopics > 0) {
            // Only log if this is a new or changed value
            if (this.topicTotals[sectionNumber] !== totalTopics) {
                this.topicTotals[sectionNumber] = totalTopics;
                // Save to localStorage for persistence
                this.saveToStorage();
                console.log(`Updated topic total for Section ${sectionNumber}: ${totalTopics} topics`);
            }
        }
    },

    /**
     * Register section data when a section data file loads
     */
    registerSectionData(sectionNumber, sectionData) {
        if (sectionData && sectionData.metadata) {
            let totalTopics = 0;
            
            // Handle both getter functions and direct values
            if (typeof sectionData.metadata.totalTopics === 'function') {
                totalTopics = sectionData.metadata.totalTopics();
            } else if (typeof sectionData.metadata.totalTopics === 'number') {
                totalTopics = sectionData.metadata.totalTopics;
            } else if (sectionData.metadata.subsections) {
                // Calculate from subsections if totalTopics is not available
                totalTopics = Object.values(sectionData.metadata.subsections)
                    .reduce((total, section) => total + (section.count || 0), 0);
            }
            
            if (totalTopics > 0) {
                this.updateTopicTotal(sectionNumber, totalTopics);
            }
        }
    },

    /**
     * Save registry to localStorage for persistence
     */
    saveToStorage() {
        try {
            const registryData = {
                topicTotals: this.topicTotals,
                version: '1.0',
                timestamp: Date.now()
            };
            localStorage.setItem('ccna_section_registry', JSON.stringify(registryData));
        } catch (e) {
            console.warn('Failed to save section registry to localStorage:', e);
        }
    },

    /**
     * Load registry from localStorage
     */
    loadFromStorage() {
        try {
            const stored = localStorage.getItem('ccna_section_registry');
            if (stored) {
                const data = JSON.parse(stored);
                if (data.topicTotals) {
                    this.topicTotals = { ...this.topicTotals, ...data.topicTotals };
                    console.log('Loaded section registry from storage');
                    return true;
                }
            }
        } catch (e) {
            console.warn('Failed to load section registry from localStorage:', e);
        }
        return false;
    },

    /**
     * Initialize the registry
     */
    init() {
        this.loadFromStorage();
        console.log('CCNA Section Registry initialized');
    }
};

// Auto-initialize when loaded
document.addEventListener('DOMContentLoaded', () => {
    CCNA_SECTION_REGISTRY.init();
});

// Global export for use in other scripts
if (typeof window !== 'undefined') {
    window.CCNA_SECTION_REGISTRY = CCNA_SECTION_REGISTRY;
}

// Node.js export for potential server-side use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CCNA_SECTION_REGISTRY;
}/**
 * User Identity Management Module for CCNA Study Hub
 * Centralized user identification and persistence across all tracking systems
 * Eliminates code duplication between shared-progress.js and anonymous-progress-tracker.js
 */

class CCNAUserIdentity {
    static instance = null;
    
    constructor() {
        if (CCNAUserIdentity.instance) {
            return CCNAUserIdentity.instance;
        }
        
        this.cachedUserId = null;
        this.cachedAnonymousId = null;
        CCNAUserIdentity.instance = this;
    }

    /**
     * Get cookie value by name
     * @param {string} name - Cookie name
     * @returns {string|null} Cookie value or null if not found
     */
    getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
        return null;
    }

    /**
     * Set cookie with long expiration
     * @param {string} name - Cookie name
     * @param {string} value - Cookie value
     * @param {number} days - Expiration in days (default: 10 years)
     */
    setCookie(name, value, days = 3650) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = `expires=${date.toUTCString()}`;
        document.cookie = `${name}=${value};${expires};path=/;SameSite=Strict`;
    }

    /**
     * Generate browser fingerprint for fallback identification
     * Creates a consistent identifier based on browser characteristics
     * @returns {string} Browser fingerprint hash
     */
    generateBrowserFingerprint() {
        const nav = navigator;
        const screen = window.screen;

        const fingerprint = [
            nav.userAgent,
            nav.language,
            screen.colorDepth,
            screen.width + 'x' + screen.height,
            new Date().getTimezoneOffset(),
            !!window.sessionStorage,
            !!window.localStorage
        ].join('|');

        let hash = 0;
        for (let i = 0; i < fingerprint.length; i++) {
            const char = fingerprint.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }

        return 'fp_' + Math.abs(hash).toString(36);
    }

    /**
     * Generate new user ID with specified format
     * @param {string} prefix - ID prefix ('user_' or 'anon_')
     * @param {boolean} useUuid - Whether to use UUID format (for anonymous users)
     * @returns {string} Generated user ID
     */
    generateNewUserId(prefix = 'user_', useUuid = false) {
        if (useUuid) {
            // Generate cryptographically secure UUID v4 format
            if (crypto && crypto.randomUUID) {
                // Use modern crypto.randomUUID() if available (requires HTTPS)
                return prefix + crypto.randomUUID();
            } else if (crypto && crypto.getRandomValues) {
                // Fallback to crypto.getRandomValues with proper UUID v4 format
                const array = new Uint8Array(16);
                crypto.getRandomValues(array);
                
                // Set version (4) and variant bits according to RFC 4122
                array[6] = (array[6] & 0x0f) | 0x40; // Version 4
                array[8] = (array[8] & 0x3f) | 0x80; // Variant 10
                
                // Convert to hex string with proper UUID format
                const hex = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
                return prefix + [
                    hex.slice(0, 8),
                    hex.slice(8, 12),
                    hex.slice(12, 16),
                    hex.slice(16, 20),
                    hex.slice(20, 32)
                ].join('-');
            } else {
                // Final fallback for very old browsers (less secure)
                console.warn('Crypto API not available, using fallback UUID generation');
                return prefix + 'xxxx-xxxx-4xxx-yxxx-xxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                }) + '-' + Date.now().toString(36);
            }
        } else {
            // Generate timestamp-based ID for regular users with crypto random suffix
            const timestamp = Date.now().toString(36);
            
            if (crypto && crypto.getRandomValues) {
                const array = new Uint8Array(6);
                crypto.getRandomValues(array);
                const randomSuffix = Array.from(array, byte => byte.toString(36)).join('');
                return prefix + timestamp + '_' + randomSuffix;
            } else {
                // Fallback for non-crypto environments
                return prefix + timestamp + '_' + Math.random().toString(36).substr(2, 9);
            }
        }
    }

    /**
     * Store user ID in all persistence locations
     * @param {string} userId - User ID to store
     * @param {string} type - 'ccna' or 'anonymous'
     */
    storeUserId(userId, type = 'ccna') {
        const cookieName = type === 'anonymous' ? 'anonymous_user_id' : 'ccna_user_id';
        const localStorageKey = type === 'anonymous' ? 'anonymous_user_id' : 'ccna_user_id';
        const fingerprintKey = type === 'anonymous' ? 'anon_id_' : 'ccna_uid_';

        // Store in cookie and localStorage
        this.setCookie(cookieName, userId);
        localStorage.setItem(localStorageKey, userId);

        // Store with fingerprint mapping for recovery
        const fingerprint = this.generateBrowserFingerprint();
        localStorage.setItem(`${fingerprintKey}${fingerprint}`, userId);
    }

    /**
     * Retrieve user ID from all persistence locations
     * Priority: 1) Cookie, 2) localStorage, 3) Browser fingerprint, 4) Generate new
     * @param {string} type - 'ccna' or 'anonymous'
     * @returns {string} User ID
     */
    retrieveUserId(type = 'ccna') {
        const cookieName = type === 'anonymous' ? 'anonymous_user_id' : 'ccna_user_id';
        const localStorageKey = type === 'anonymous' ? 'anonymous_user_id' : 'ccna_user_id';
        const fingerprintKey = type === 'anonymous' ? 'anon_id_' : 'ccna_uid_';
        const prefix = type === 'anonymous' ? 'user_' : 'user_';
        const useUuid = type === 'anonymous';

        // Try cookie first (survives cache clears)
        let userId = this.getCookie(cookieName);

        if (!userId) {
            // Try localStorage second
            userId = localStorage.getItem(localStorageKey);
        }

        if (!userId) {
            // Try browser fingerprint as fallback
            const fingerprint = this.generateBrowserFingerprint();
            userId = localStorage.getItem(`${fingerprintKey}${fingerprint}`);

            if (userId) {
                console.log(`Recovered ${type} user ID from browser fingerprint`);
            }
        }

        if (!userId) {
            // Generate new user ID
            userId = this.generateNewUserId(prefix, useUuid);
            console.log(`Generated new ${type} user ID: ${userId}`);
        }

        // Store in all locations for maximum persistence
        this.storeUserId(userId, type);

        return userId;
    }

    /**
     * Get or create CCNA user ID (for shared progress tracking)
     * @returns {string} CCNA user ID
     */
    getOrCreateCCNAUserId() {
        if (!this.cachedUserId) {
            this.cachedUserId = this.retrieveUserId('ccna');
        }
        return this.cachedUserId;
    }

    /**
     * Get or create anonymous user ID (for API progress tracking)
     * @returns {string} Anonymous user ID
     */
    getOrCreateAnonymousUserId() {
        if (!this.cachedAnonymousId) {
            this.cachedAnonymousId = this.retrieveUserId('anonymous');
        }
        return this.cachedAnonymousId;
    }

    /**
     * Clear all user identification data (for testing or reset)
     * @param {string} type - 'ccna', 'anonymous', or 'all'
     */
    clearUserData(type = 'all') {
        if (type === 'ccna' || type === 'all') {
            // Clear CCNA user data
            document.cookie = 'ccna_user_id=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
            localStorage.removeItem('ccna_user_id');
            
            // Clear fingerprint mappings
            const fingerprint = this.generateBrowserFingerprint();
            localStorage.removeItem(`ccna_uid_${fingerprint}`);
            
            this.cachedUserId = null;
        }

        if (type === 'anonymous' || type === 'all') {
            // Clear anonymous user data
            document.cookie = 'anonymous_user_id=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
            localStorage.removeItem('anonymous_user_id');
            
            // Clear fingerprint mappings
            const fingerprint = this.generateBrowserFingerprint();
            localStorage.removeItem(`anon_id_${fingerprint}`);
            
            this.cachedAnonymousId = null;
        }
    }

    /**
     * Get current user identity information for debugging
     * @returns {object} Current user identity state
     */
    getIdentityInfo() {
        return {
            ccnaUserId: this.getOrCreateCCNAUserId(),
            anonymousUserId: this.getOrCreateAnonymousUserId(),
            browserFingerprint: this.generateBrowserFingerprint(),
            hasCCNACookie: !!this.getCookie('ccna_user_id'),
            hasAnonymousCookie: !!this.getCookie('anonymous_user_id'),
            hasCCNALocalStorage: !!localStorage.getItem('ccna_user_id'),
            hasAnonymousLocalStorage: !!localStorage.getItem('anonymous_user_id')
        };
    }
}

// Create singleton instance
window.CCNAUserIdentity = CCNAUserIdentity;

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CCNAUserIdentity;
}/**
 * Unified Progress Tracker for CCNA Study Guide
 * Replaces the three overlapping progress systems with a single, clean architecture
 * Uses strategy pattern for storage and state machine for sync management
 * 
 * Phase 2 Consolidation - October 2025
 */

/**
 * Progress State Machine
 * Manages the current state of progress operations
 */
class ProgressStateMachine {
    constructor() {
        this.state = 'idle';
        this.listeners = [];
    }

    /**
     * Valid state transitions
     */
    static TRANSITIONS = {
        'idle': ['syncing', 'error'],
        'syncing': ['synced', 'error', 'idle'],
        'synced': ['syncing', 'idle'],
        'error': ['syncing', 'idle']
    };

    /**
     * Transition to a new state
     * @param {string} newState - Target state
     */
    transition(newState) {
        if (!ProgressStateMachine.TRANSITIONS[this.state]?.includes(newState)) {
            console.warn(`Invalid state transition: ${this.state} -> ${newState}`);
            return false;
        }

        const oldState = this.state;
        this.state = newState;
        
        // Notify listeners
        this.listeners.forEach(callback => {
            try {
                callback(newState, oldState);
            } catch (error) {
                console.warn('Error in state machine listener:', error);
            }
        });

        return true;
    }

    /**
     * Get current state
     */
    getState() {
        return this.state;
    }

    /**
     * Add state change listener
     */
    onStateChange(callback) {
        this.listeners.push(callback);
    }

    /**
     * Remove state change listener
     */
    removeStateListener(callback) {
        this.listeners = this.listeners.filter(listener => listener !== callback);
    }

    /**
     * Cleanup
     */
    destroy() {
        this.listeners = [];
        this.state = 'idle';
    }
}

/**
 * Storage Factory - Creates appropriate storage adapters
 */
class StorageFactory {
    /**
     * Create storage adapter based on mode
     * @param {string} mode - 'local', 'remote', or 'hybrid'
     * @param {Object} config - Configuration for the adapter
     */
    static create(mode, config = {}) {
        switch (mode) {
            case 'local':
                return new LocalStorageAdapter(config);
            case 'remote':
                return new APIStorageAdapter(config);
            case 'hybrid':
                return new HybridStorageAdapter(config);
            default:
                console.warn(`Unknown storage mode: ${mode}, falling back to local`);
                return new LocalStorageAdapter(config);
        }
    }
}

/**
 * Base Storage Adapter Interface
 */
class StorageAdapter {
    async save(topicData) {
        throw new Error('save() must be implemented by storage adapter');
    }

    async load(sectionNumber = null) {
        throw new Error('load() must be implemented by storage adapter');
    }

    async clear(sectionNumber = null) {
        throw new Error('clear() must be implemented by storage adapter');
    }

    isOnline() {
        return navigator.onLine;
    }

    destroy() {
        // Override in subclasses if cleanup needed
    }
}

/**
 * Local Storage Adapter - localStorage only
 */
class LocalStorageAdapter extends StorageAdapter {
    constructor(config = {}) {
        super();
        this.storageKey = config.storageKey || 'ccna_progress_v4';
        this.dataVersion = config.dataVersion || '4.0';
        this.checkDataVersion();
    }

    checkDataVersion() {
        const currentVersion = localStorage.getItem('ccna_data_version');
        if (currentVersion !== this.dataVersion) {
            // Clear stale data
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('ccna_progress') || key.startsWith('ccna_chapter')) {
                    localStorage.removeItem(key);
                }
            });
            localStorage.setItem('ccna_data_version', this.dataVersion);
            console.log('Cleared stale progress data due to version change');
        }
    }

    async save(topicData) {
        const { sectionNumber, topicTitle, completed, timestamp } = topicData;
        
        try {
            const allProgress = await this.load();
            
            if (!allProgress[sectionNumber]) {
                allProgress[sectionNumber] = {};
            }

            if (completed) {
                allProgress[sectionNumber][topicTitle] = {
                    completed: true,
                    completedAt: timestamp || new Date().toISOString(),
                    studyTime: 0
                };
            } else {
                delete allProgress[sectionNumber][topicTitle];
            }

            localStorage.setItem(this.storageKey, JSON.stringify(allProgress));
            return true;
        } catch (error) {
            console.error('LocalStorage save failed:', error);
            return false;
        }
    }

    async load(sectionNumber = null) {
        try {
            const stored = localStorage.getItem(this.storageKey);
            const allProgress = stored ? JSON.parse(stored) : {};
            
            if (sectionNumber) {
                return allProgress[sectionNumber] || {};
            }
            
            return allProgress;
        } catch (error) {
            console.error('LocalStorage load failed:', error);
            return {};
        }
    }

    async clear(sectionNumber = null) {
        try {
            if (sectionNumber) {
                const allProgress = await this.load();
                delete allProgress[sectionNumber];
                localStorage.setItem(this.storageKey, JSON.stringify(allProgress));
            } else {
                localStorage.removeItem(this.storageKey);
            }
            return true;
        } catch (error) {
            console.error('LocalStorage clear failed:', error);
            return false;
        }
    }
}

/**
 * API Storage Adapter - Server-side storage only
 */
class APIStorageAdapter extends StorageAdapter {
    constructor(config = {}) {
        super();
        this.apiBase = config.apiBase || '/api/v1/progress';
        this.userId = config.userId || this.generateUserId();
        this.maxRetries = config.maxRetries || 3;
    }

    generateUserId() {
        // Use same logic as original anonymous tracker
        if (window.CCNAUserIdentity) {
            const userIdentity = new CCNAUserIdentity();
            return userIdentity.getOrCreateAnonymousUserId();
        }
        // Fallback
        let userId = localStorage.getItem('anonymous_user_id');
        if (!userId) {
            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('anonymous_user_id', userId);
        }
        return userId;
    }

    async save(topicData) {
        if (!this.isOnline()) {
            throw new Error('Network unavailable');
        }

        const { sectionNumber, topicTitle, completed, timestamp } = topicData;
        
        const progressData = {
            userId: this.userId,
            sectionNumber,
            topicTitle,
            completed,
            timestamp: timestamp || new Date().toISOString()
        };

        try {
            const response = await fetch(`${this.apiBase}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(progressData)
            });

            if (response.ok) {
                console.log(`API save successful: ${topicTitle} in section ${sectionNumber}`);
                return true;
            } else {
                throw new Error(`Server responded with status: ${response.status}`);
            }
        } catch (error) {
            console.error('API save failed:', error);
            throw error;
        }
    }

    async load(sectionNumber = null) {
        if (!this.isOnline()) {
            throw new Error('Network unavailable');
        }

        try {
            // Use a more discrete fetch approach for 404s (expected for new users)
            const response = await fetch(`${this.apiBase}/${this.userId}`, {
                headers: {
                    'Accept': 'application/json',
                },
                cache: 'no-cache'
            }).catch(async (fetchError) => {
                // For network errors, just return a mock 404 response
                console.log('🌐 Network issue - using local storage only');
                return { ok: false, status: 404, statusText: 'Network Error' };
            });
            
            if (response.ok) {
                const progressData = await response.json();
                console.log('✓ Progress loaded from server');
                
                if (sectionNumber) {
                    return progressData[sectionNumber] || {};
                }
                
                return progressData;
            } else if (response.status === 404) {
                // New user - no progress yet (this is expected behavior, not an error)
                console.log('ℹ️  Expected: New user with no saved progress yet');
                return {};
            } else {
                throw new Error(`Server responded with status: ${response.status}`);
            }
        } catch (error) {
            console.error('API load failed:', error);
            throw error;
        }
    }

    async clear(sectionNumber = null) {
        if (!this.isOnline()) {
            throw new Error('Network unavailable');
        }

        try {
            const endpoint = sectionNumber 
                ? `${this.apiBase}/${this.userId}/${sectionNumber}`
                : `${this.apiBase}/${this.userId}`;
                
            const response = await fetch(endpoint, {
                method: 'DELETE'
            });
            
            return response.ok;
        } catch (error) {
            console.error('API clear failed:', error);
            throw error;
        }
    }

    getUserId() {
        return this.userId;
    }
}

/**
 * Hybrid Storage Adapter - localStorage + API with offline queue
 */
class HybridStorageAdapter extends StorageAdapter {
    constructor(config = {}) {
        super();
        this.localStorage = new LocalStorageAdapter(config);
        this.apiStorage = new APIStorageAdapter(config);
        this.syncQueue = [];
        this.queueKey = `sync_queue_${this.apiStorage.getUserId()}`;
        this.listeners = [];
        
        this.loadSyncQueue();
        this.setupNetworkListeners();
    }

    setupNetworkListeners() {
        const onlineHandler = () => {
            console.log('Network restored - processing sync queue');
            this.processSyncQueue();
        };

        const offlineHandler = () => {
            console.log('Network lost - queuing operations');
        };

        window.addEventListener('online', onlineHandler);
        window.addEventListener('offline', offlineHandler);
        
        // Track listeners for cleanup
        this.listeners.push(
            { element: window, event: 'online', handler: onlineHandler },
            { element: window, event: 'offline', handler: offlineHandler }
        );
    }

    async save(topicData) {
        // Always save to localStorage immediately
        const localSuccess = await this.localStorage.save(topicData);
        
        if (!localSuccess) {
            console.error('Critical: localStorage save failed');
            return false;
        }

        // Try to sync to API if online
        if (this.isOnline()) {
            try {
                const apiSuccess = await this.apiStorage.save(topicData);
                if (apiSuccess) {
                    console.log('Hybrid save: both local and API successful');
                    return true;
                }
            } catch (error) {
                console.warn('API save failed, queuing for later:', error.message);
            }
        }

        // Queue for later sync if API failed or offline
        this.queueForSync('save', topicData);
        console.log('Hybrid save: local successful, API queued');
        return true;
    }

    async load(sectionNumber = null) {
        // Try API first if online, fallback to localStorage
        if (this.isOnline()) {
            try {
                const apiData = await this.apiStorage.load(sectionNumber);
                
                // Merge with local data if needed
                const localData = await this.localStorage.load(sectionNumber);
                const mergedData = this.mergeProgressData(apiData, localData);
                
                // Update localStorage with merged data
                if (JSON.stringify(mergedData) !== JSON.stringify(localData)) {
                    await this.updateLocalWithMerged(mergedData, sectionNumber);
                }
                
                return mergedData;
            } catch (error) {
                console.warn('API load failed, using localStorage:', error.message);
            }
        }

        // Fallback to localStorage
        return await this.localStorage.load(sectionNumber);
    }

    async clear(sectionNumber = null) {
        // Clear localStorage immediately
        const localSuccess = await this.localStorage.clear(sectionNumber);
        
        // Try to clear API if online
        if (this.isOnline()) {
            try {
                await this.apiStorage.clear(sectionNumber);
            } catch (error) {
                console.warn('API clear failed:', error.message);
            }
        }

        return localSuccess;
    }

    mergeProgressData(apiData, localData) {
        const merged = { ...localData };
        
        // Merge API data, preserving most recent completion
        Object.entries(apiData).forEach(([topic, apiProgress]) => {
            const localProgress = merged[topic];
            
            if (!localProgress && apiProgress.completed) {
                // Topic completed on API but not locally
                merged[topic] = apiProgress;
            } else if (localProgress && !localProgress.completed && apiProgress.completed) {
                // Local topic not completed but API shows completed
                merged[topic] = apiProgress;
            }
            // Keep local if local is more recent or both completed
        });

        return merged;
    }

    async updateLocalWithMerged(mergedData, sectionNumber) {
        if (sectionNumber) {
            // Update specific section
            const allData = await this.localStorage.load();
            allData[sectionNumber] = mergedData;
            localStorage.setItem(this.localStorage.storageKey, JSON.stringify(allData));
        } else {
            // Update all data
            localStorage.setItem(this.localStorage.storageKey, JSON.stringify(mergedData));
        }
    }

    queueForSync(operation, data) {
        const syncItem = {
            operation,
            data,
            timestamp: new Date().toISOString(),
            attempts: 0
        };
        
        this.syncQueue.push(syncItem);
        this.saveSyncQueue();
    }

    saveSyncQueue() {
        try {
            localStorage.setItem(this.queueKey, JSON.stringify(this.syncQueue));
        } catch (error) {
            console.warn('Could not persist sync queue:', error);
        }
    }

    loadSyncQueue() {
        try {
            const saved = localStorage.getItem(this.queueKey);
            if (saved) {
                this.syncQueue = JSON.parse(saved);
                console.log(`Loaded ${this.syncQueue.length} queued operations`);
                
                // Process queue if online
                if (this.isOnline()) {
                    setTimeout(() => this.processSyncQueue(), 1000);
                }
            }
        } catch (error) {
            console.warn('Could not load sync queue:', error);
            this.syncQueue = [];
        }
    }

    async processSyncQueue() {
        if (!this.isOnline() || this.syncQueue.length === 0) {
            return;
        }

        console.log(`Processing ${this.syncQueue.length} queued operations`);
        
        // Process sequentially to avoid overwhelming server
        for (let i = this.syncQueue.length - 1; i >= 0; i--) {
            const item = this.syncQueue[i];
            item.attempts++;

            let success = false;
            try {
                if (item.operation === 'save') {
                    success = await this.apiStorage.save(item.data);
                }
            } catch (error) {
                console.warn(`Sync queue item failed (attempt ${item.attempts}):`, error.message);
            }

            if (success || item.attempts >= 3) {
                // Remove successfully synced or repeatedly failed items
                this.syncQueue.splice(i, 1);
            }
        }

        this.saveSyncQueue();
        
        if (this.syncQueue.length === 0) {
            console.log('All queued operations successfully synced');
        }
    }

    getSyncStatus() {
        return {
            queueLength: this.syncQueue.length,
            isOnline: this.isOnline(),
            userId: this.apiStorage.getUserId()
        };
    }

    destroy() {
        // Remove event listeners
        this.listeners.forEach(({ element, event, handler }) => {
            if (element && element.removeEventListener) {
                element.removeEventListener(event, handler);
            }
        });
        this.listeners = [];

        // Clear references
        if (this.localStorage) this.localStorage.destroy();
        if (this.apiStorage) this.apiStorage.destroy();
        this.syncQueue = [];
    }
}

/**
 * Main Progress Tracker Class
 * Single interface replacing all previous progress trackers
 */
class ProgressTracker {
    constructor(config = {}) {
        // Configuration
        this.sectionNumber = config.sectionNumber || null;
        this.storageMode = config.storageMode || 'hybrid';
        
        // Initialize storage strategy
        this.storage = StorageFactory.create(this.storageMode, {
            storageKey: `ccna_progress_v4_${this.getUserId()}`,
            apiBase: config.apiBase || '/api/v1/progress',
            userId: this.getUserId(),
            dataVersion: '4.0'
        });
        
        // Initialize state machine
        this.state = new ProgressStateMachine();
        
        // Topic management
        this.sectionTopics = {};
        this.cachedTopicTotals = null;
        
        // Event management
        this.subscribers = [];
        this.listeners = [];
        
        console.log(`📊 ProgressTracker initialized with ${this.storageMode} storage for section ${this.sectionNumber}`);
        
        // Show helpful info for new users
        if (this.storageMode === 'local') {
            console.log('💡 Starting in local-only mode. Will upgrade to server sync when you complete topics.');
        }
        
        // Setup section data listener
        this.setupSectionDataListener();
    }

    getUserId() {
        if (window.CCNAUserIdentity) {
            const userIdentity = new CCNAUserIdentity();
            return userIdentity.getOrCreateCCNAUserId();
        }
        // Fallback
        let userId = localStorage.getItem('ccna_user_id');
        if (!userId) {
            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('ccna_user_id', userId);
        }
        return userId;
    }

    setupSectionDataListener() {
        const handler = (event) => {
            console.log('Section data loaded, updating progress tracking:', event.detail);
            this.cachedTopicTotals = null; // Clear cache
            setTimeout(() => {
                this.notifySubscribers('progress-updated');
            }, 100);
        };
        
        window.addEventListener('sectionDataLoaded', handler);
        this.listeners.push({ element: window, event: 'sectionDataLoaded', handler });
    }

    /**
     * Mark a topic as completed or not completed
     * @param {string} topicTitle - Title of the topic
     * @param {boolean} completed - Whether the topic is completed
     */
    async markTopicComplete(topicTitle, completed = true) {
        if (!this.sectionNumber) {
            console.error('Cannot mark topic complete: no section number set');
            return false;
        }

        this.state.transition('syncing');
        
        const topicData = {
            sectionNumber: this.sectionNumber,
            topicTitle,
            completed,
            timestamp: new Date().toISOString()
        };

        try {
            const success = await this.storage.save(topicData);
            
            if (success) {
                this.state.transition('synced');
                this.notifySubscribers('progress-updated', { topicTitle, completed });
                console.log(`Topic ${completed ? 'completed' : 'unchecked'}: ${topicTitle}`);
                
                // Auto-upgrade to hybrid mode on first topic completion for better sync
                if (completed && this.storageMode === 'local' && navigator.onLine) {
                    console.log('🔄 Upgrading to hybrid mode for server sync...');
                    this.upgradeToHybridMode();
                }
                
                return true;
            } else {
                this.state.transition('error');
                return false;
            }
        } catch (error) {
            console.error('Error marking topic complete:', error);
            this.state.transition('error');
            this.queueForRetry(topicData);
            return false;
        }
    }

    /**
     * Check if a topic is completed
     * @param {string} topicTitle - Title of the topic
     * @param {number} sectionNumber - Optional section number (defaults to current)
     */
    async isTopicCompleted(topicTitle, sectionNumber = null) {
        const section = sectionNumber || this.sectionNumber;
        
        try {
            const sectionProgress = await this.storage.load(section);
            return !!(sectionProgress[topicTitle] && sectionProgress[topicTitle].completed);
        } catch (error) {
            console.error('Error checking topic completion:', error);
            return false;
        }
    }

    /**
     * Get all progress data
     */
    async getAllProgress() {
        try {
            return await this.storage.load();
        } catch (error) {
            console.error('Error loading all progress:', error);
            return {};
        }
    }

    /**
     * Get progress for a specific section
     */
    async getSectionProgress(sectionNumber = null) {
        const section = sectionNumber || this.sectionNumber;
        
        try {
            return await this.storage.load(section);
        } catch (error) {
            console.error('Error loading section progress:', error);
            return {};
        }
    }

    /**
     * Set topics for a section (called by SectionLoader)
     */
    setSectionTopics(sectionNumber, topicTitles) {
        if (Array.isArray(topicTitles)) {
            this.sectionTopics[sectionNumber] = topicTitles;
            this.updateTopicTotalsCache();
            console.log(`Set ${topicTitles.length} topics for section ${sectionNumber}`);
        }
    }

    updateTopicTotalsCache() {
        if (window.CCNA_SECTION_REGISTRY && this.sectionNumber && this.sectionTopics[this.sectionNumber]) {
            const count = this.sectionTopics[this.sectionNumber].length;
            window.CCNA_SECTION_REGISTRY.updateTopicTotal(this.sectionNumber, count);
        }
    }

    /**
     * Get overall progress across all sections
     */
    async getOverallProgress() {
        try {
            const allProgress = await this.getAllProgress();
            let totalCompleted = 0;
            let totalTopics = 0;
            
            // Get topic totals from registry
            if (window.CCNA_SECTION_REGISTRY) {
                const totals = window.CCNA_SECTION_REGISTRY.getAllTopicTotals();
                
                [1, 2, 3, 4, 5, 6].forEach(section => {
                    const sectionProgress = allProgress[section] || {};
                    const completed = Object.keys(sectionProgress).filter(topic => 
                        sectionProgress[topic] && sectionProgress[topic].completed
                    ).length;
                    
                    totalCompleted += completed;
                    totalTopics += totals[section] || 0;
                });
            }
            
            return {
                completed: totalCompleted,
                total: totalTopics,
                percentage: totalTopics > 0 ? Math.round((totalCompleted / totalTopics) * 100) : 0
            };
        } catch (error) {
            console.error('Error calculating overall progress:', error);
            return { completed: 0, total: 0, percentage: 0 };
        }
    }

    /**
     * Get progress for a specific section with stats
     */
    async getSectionProgressStats(sectionNumber = null) {
        const section = sectionNumber || this.sectionNumber;
        
        try {
            const sectionProgress = await this.getSectionProgress(section);
            const completed = Object.keys(sectionProgress).filter(topic => 
                sectionProgress[topic] && sectionProgress[topic].completed
            ).length;
            
            let total = 0;
            if (this.sectionTopics[section]) {
                total = this.sectionTopics[section].length;
            } else if (window.CCNA_SECTION_REGISTRY) {
                const totals = window.CCNA_SECTION_REGISTRY.getAllTopicTotals();
                total = totals[section] || 0;
            }
            
            return {
                completed,
                total,
                percentage: total > 0 ? Math.round((completed / total) * 100) : 0
            };
        } catch (error) {
            console.error('Error calculating section progress:', error);
            return { completed: 0, total: 0, percentage: 0 };
        }
    }

    /**
     * Get topic completion states for UI synchronization
     */
    async getTopicCompletionStates() {
        if (!this.sectionNumber) {
            return {};
        }

        try {
            const sectionProgress = await this.getSectionProgress();
            const completionStates = {};
            
            if (this.sectionTopics[this.sectionNumber]) {
                this.sectionTopics[this.sectionNumber].forEach(title => {
                    completionStates[title] = !!(sectionProgress[title] && sectionProgress[title].completed);
                });
            }
            
            return completionStates;
        } catch (error) {
            console.error('Error getting topic completion states:', error);
            return {};
        }
    }

    /**
     * Clear progress data
     */
    async clearProgress(sectionNumber = null) {
        try {
            const success = await this.storage.clear(sectionNumber);
            if (success) {
                this.notifySubscribers('progress-cleared', { sectionNumber });
                console.log('Progress data cleared');
            }
            return success;
        } catch (error) {
            console.error('Error clearing progress:', error);
            return false;
        }
    }

    /**
     * Subscribe to progress events
     */
    subscribe(callback) {
        this.subscribers.push(callback);
    }

    /**
     * Unsubscribe from progress events
     */
    unsubscribe(callback) {
        this.subscribers = this.subscribers.filter(cb => cb !== callback);
    }

    /**
     * Notify subscribers of progress changes
     */
    notifySubscribers(eventType, data = {}) {
        console.log(`🔔 Notifying ${this.subscribers.length} subscribers of event: ${eventType}`, data);
        this.subscribers.forEach((callback, index) => {
            try {
                console.log(`📢 Calling subscriber ${index + 1}/${this.subscribers.length}`);
                callback(eventType, data);
            } catch (error) {
                console.warn('Error in progress tracker subscriber:', error);
            }
        });
        
        // Also dispatch window events for global progress bars
        if (eventType === 'progress-updated') {
            console.log('📡 Dispatching window progressUpdated event');
            window.dispatchEvent(new CustomEvent('progressUpdated', {
                detail: { topicTitle: data.topicTitle, completed: data.completed, sectionNumber: this.sectionNumber }
            }));
        }
        
        console.log(`✅ Finished notifying subscribers for event: ${eventType}`);
    }

    /**
     * Get current sync status
     */
    getSyncStatus() {
        const baseStatus = {
            state: this.state.getState(),
            sectionNumber: this.sectionNumber,
            storageMode: this.storageMode
        };

        if (this.storage.getSyncStatus) {
            return { ...baseStatus, ...this.storage.getSyncStatus() };
        }

        return baseStatus;
    }

    /**
     * Force full synchronization (for hybrid mode)
     */
    async forceSync() {
        if (this.storage.processSyncQueue) {
            await this.storage.processSyncQueue();
        }
    }

    queueForRetry(topicData) {
        if (this.storage.queueForSync) {
            this.storage.queueForSync('save', topicData);
        }
    }

    /**
     * Upgrade from local-only to hybrid mode when user starts making progress
     */
    async upgradeToHybridMode() {
        if (this.storageMode === 'hybrid') {
            return; // Already hybrid
        }

        try {
            console.log('📡 Upgrading storage to hybrid mode...');
            
            // Get current local data
            const localData = await this.storage.load();
            
            // Create new hybrid storage
            const hybridStorage = StorageFactory.create('hybrid', {
                storageKey: `ccna_progress_v4_${this.getUserId()}`,
                apiBase: '/api/v1/progress',
                userId: this.getUserId(),
                dataVersion: '4.0'
            });
            
            // Migrate existing data to new storage with rate limiting
            const completedTopics = [];
            for (const [section, topics] of Object.entries(localData)) {
                for (const [topic, data] of Object.entries(topics)) {
                    if (data && data.completed) {
                        completedTopics.push({
                            sectionNumber: parseInt(section),
                            topicTitle: topic,
                            completed: true,
                            timestamp: data.completedAt || new Date().toISOString()
                        });
                    }
                }
            }
            
            // Save with delays to avoid rate limiting (max 2 per second)
            console.log(`📦 Migrating ${completedTopics.length} completed topics to hybrid mode...`);
            for (let i = 0; i < completedTopics.length; i++) {
                await hybridStorage.save(completedTopics[i]);
                
                // Add 500ms delay between saves to avoid triggering DoS protection
                if (i < completedTopics.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            // Cleanup old storage
            if (this.storage.destroy) {
                this.storage.destroy();
            }
            
            // Switch to hybrid storage
            this.storage = hybridStorage;
            this.storageMode = 'hybrid';
            
            // Update user preference
            localStorage.setItem('progress_tracker_mode', 'hybrid');
            
            console.log('✅ Successfully upgraded to hybrid mode');
            
        } catch (error) {
            console.warn('Failed to upgrade to hybrid mode:', error);
            // Continue with local storage if upgrade fails
        }
    }

    // ============================================================================
    // Legacy Method Names for Backward Compatibility
    // ============================================================================

    /**
     * Legacy method: markTopicCompleted - maps to markTopicComplete
     */
    async markTopicCompleted(topicTitle, completed = true) {
        return await this.markTopicComplete(topicTitle, completed);
    }

    /**
     * Legacy method: setChapterTopics - maps to setSectionTopics
     */
    setChapterTopics(chapterNumber, topicTitles) {
        this.setSectionTopics(chapterNumber, topicTitles);
    }

    /**
     * Legacy method: getOverallProgress - already exists but ensure sync compatibility
     */
    // (method already exists)

    /**
     * Legacy method: getTopicCompletionStates - already exists but ensure sync compatibility  
     */
    // (method already exists)

    /**
     * Cleanup method to prevent memory leaks
     */
    destroy() {
        // Remove event listeners
        this.listeners.forEach(({ element, event, handler }) => {
            if (element && element.removeEventListener) {
                element.removeEventListener(event, handler);
            }
        });
        this.listeners = [];

        // Clear subscribers
        this.subscribers = [];

        // Cleanup storage
        if (this.storage && this.storage.destroy) {
            this.storage.destroy();
        }

        // Cleanup state machine
        if (this.state) {
            this.state.destroy();
        }

        console.log('ProgressTracker destroyed and cleaned up');
    }
}

// Export classes for global use
window.ProgressTracker = ProgressTracker;
window.StorageFactory = StorageFactory;
window.LocalStorageAdapter = LocalStorageAdapter;
window.APIStorageAdapter = APIStorageAdapter;
window.HybridStorageAdapter = HybridStorageAdapter;

console.log('Unified ProgressTracker system loaded');/**
 * Section Overall Progress Display - CCNA Study Guide
 * Handles display of overall progress across all sections on individual section pages
 * Following Golden Rules hierarchy - Frontend Application Layer
 */

class SectionOverallProgressDisplay {
    constructor() {
        this.globalProgressData = null;
        this.progressTracker = null;
        this.isInitialized = false;
        
        console.log('SectionOverallProgressDisplay initializing...');
        this.initialize();
    }

    /**
     * Initialize overall progress display for section pages
     */
    async initialize() {
        try {
            // Load global progress data from sessionStorage
            this.loadGlobalProgressData();
            
            // Initialize progress tracker if needed
            await this.initializeProgressTracker();
            
            // Update master progress bar if it exists
            await this.updateMasterProgressBar();
            
            // Ensure the standard progress tracker also updates its bars
            if (this.progressTracker && this.progressTracker.updateAllProgressBars) {
                this.progressTracker.updateAllProgressBars();
            }
            
            // Set up event listeners
            this.setupEventListeners();
            
            this.isInitialized = true;
            console.log('Section overall progress display initialized');
            
        } catch (error) {
            console.error('Failed to initialize section overall progress display:', error);
        }
    }

    /**
     * Load global progress data from sessionStorage
     */
    loadGlobalProgressData() {
        try {
            const data = sessionStorage.getItem('ccna_global_progress_data');
            if (data) {
                this.globalProgressData = JSON.parse(data);
                console.log('Loaded global progress data:', this.globalProgressData);
            } else {
                console.warn('No global progress data found in sessionStorage');
            }
        } catch (error) {
            console.error('Failed to load global progress data:', error);
        }
    }

    /**
     * Initialize progress tracker for this section
     */
    async initializeProgressTracker() {
        if (!this.progressTracker) {
            // Use new unified progress tracking system
            this.progressTracker = new ProgressTracker({
                sectionNumber: null, // null = all sections
                storageMode: 'hybrid' // Use hybrid mode for immediate server sync
            });
            console.log('Using unified ProgressTracker for section overall progress');
            
            // Give the tracker a moment to initialize and load data
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    /**
     * Update the master progress bar with overall progress
     */
    async updateMasterProgressBar() {
        const masterProgressCard = document.getElementById('master-progress-card');
        const progressText = document.getElementById('progressText');
        const progressBar = document.getElementById('progressBar');
        const progressDetails = document.getElementById('progressDetails');
        
        if (!masterProgressCard) {
            console.log('Master progress bar not found on this page');
            return;
        }

        try {
            // Get overall progress from tracker (handle both sync and async)
            let overallProgress;
            if (this.progressTracker.getOverallProgress) {
                const result = this.progressTracker.getOverallProgress();
                // Handle both sync and async responses
                overallProgress = result && typeof result.then === 'function' ? await result : result;
            } else {
                overallProgress = { completed: 0, total: 0, percentage: 0 };
            }
            
            const totalTopics = this.globalProgressData?.totalTopics || overallProgress.total || 0;
            const completedTopics = overallProgress.completed || 0;
            const progressPercentage = overallProgress.percentage || 0;
            
            console.log('Progress data:', { totalTopics, completedTopics, progressPercentage });
            
            // Update progress text
            if (progressText) {
                progressText.textContent = `${progressPercentage}%`;
            }
            
            // Update progress bar
            if (progressBar) {
                progressBar.style.width = `${progressPercentage}%`;
                progressBar.style.backgroundColor = this.getProgressColor(progressPercentage);
            }
            
            // Update progress details
            if (progressDetails) {
                progressDetails.textContent = `${completedTopics} of ${totalTopics} topics completed`;
            }
            
            console.log(`Master progress updated: ${completedTopics}/${totalTopics} (${progressPercentage}%)`);
            
        } catch (error) {
            console.error('Failed to update master progress bar:', error);
        }
    }

    /**
     * Get color for progress bar based on percentage
     */
    getProgressColor(percentage) {
        if (percentage >= 80) return '#10b981'; // green
        if (percentage >= 60) return '#f59e0b'; // yellow
        if (percentage >= 40) return '#f97316'; // orange
        return '#ef4444'; // red
    }

    /**
     * Set up event listeners for progress updates
     */
    setupEventListeners() {
        // Listen for progress updates
        window.addEventListener('progressUpdated', () => {
            this.updateMasterProgressBar();
        });
        
        // Listen for overall progress initialization
        window.addEventListener('overallProgressInitialized', () => {
            this.loadGlobalProgressData();
            this.updateMasterProgressBar();
        });
    }

    /**
     * Force refresh of progress display
     */
    async refresh() {
        this.loadGlobalProgressData();
        await this.updateMasterProgressBar();
    }
}

// Initialize when DOM is ready, but only on section pages (not sections.html)
document.addEventListener('DOMContentLoaded', function() {
    // Check if this is a section page (section.html?section=N or section1.html, section2.html, etc.)
    const isUnifiedSectionPage = window.location.pathname.includes('section.html') && 
                                new URLSearchParams(window.location.search).has('section');
    const isLegacySectionPage = window.location.pathname.includes('section') && 
                               !window.location.pathname.includes('sections.html') &&
                               !window.location.pathname.includes('section.html');
    
    if (isUnifiedSectionPage || isLegacySectionPage) {
        window.sectionOverallProgressDisplay = new SectionOverallProgressDisplay();
    }
});/**
 * Shared Section Loader for CCNA Study Guide
 * Eliminates code duplication across section*.html files
 */

class SectionLoader {
    constructor(sectionNumber, sectionData = null) {
        this.sectionNumber = sectionNumber;
        this.progressTracker = null;
        this.currentTopic = null;
        this.currentCardElement = null;
        this.data = sectionData;
        this.listeners = []; // Track event listeners for cleanup
        this.cardListeners = []; // Track card click listeners
        this.dom = {}; // Cache DOM elements
        
        this.init();
    }
    
    /**
     * Cache frequently used DOM elements to reduce query overhead
     */
    cacheDOMElements() {
        // Modal elements
        this.dom.studyModal = document.getElementById('studyModal');
        this.dom.modalContent = document.getElementById('modalContent');
        this.dom.modalTitle = document.getElementById('modalTitle');
        this.dom.modalDescription = document.getElementById('modalDescription');
        this.dom.modalSvg = document.getElementById('modalSvg');
        this.dom.markCompleted = document.getElementById('markCompleted');
        
        // Details modal elements
        this.dom.detailsModal = document.getElementById('detailsModal');
        this.dom.detailsModalContent = document.getElementById('detailsModalContent');
        this.dom.detailsModalTitle = document.getElementById('detailsModalTitle');
        this.dom.detailsModalBody = document.getElementById('detailsModalBody');
        
        // Button elements (for event listeners)
        this.dom.closeModal = document.getElementById('closeModal');
        this.dom.viewDetails = document.getElementById('viewDetails');
        this.dom.closeDetails = document.getElementById('closeDetails');
        
        console.log('DOM elements cached for SectionLoader');
    }
    
    async init() {
        try {
            // Initialize progress tracker with new unified system
            this.progressTracker = new ProgressTracker({
                sectionNumber: this.sectionNumber,
                storageMode: 'hybrid' // Use hybrid mode for immediate server sync
            });
            console.log('Using unified ProgressTracker system');
            
            // Initialize ALL global styling (replaces embedded CSS)
            if (typeof CCNAConfig !== 'undefined' && CCNAConfig.initializeGlobalStyling) {
                CCNAConfig.initializeGlobalStyling();
            } else {
                console.warn('CCNAConfig not available - styling may not be applied correctly');
            }
            
            // Get the section data - prioritize passed data, fallback to global variable
            if (!this.data) {
                this.data = window[`SECTION${this.sectionNumber}_DATA`];
            }
            
            if (!this.data) {
                this.handleDataError(`Section ${this.sectionNumber} data not loaded. Pass data directly to constructor or ensure window.SECTION${this.sectionNumber}_DATA exists.`);
                return;
            }
            
            // Validate data structure
            if (!this.validateSectionData(this.data)) {
                this.handleDataError(`Section ${this.sectionNumber} data structure is invalid.`);
                return;
            }
            
            // Cache DOM elements for performance
            this.cacheDOMElements();
            
            // Populate grids with topic cards
            this.populateGrids();
            
            // Extract and provide topics to progress tracker
            this.provideTopicsToProgressTracker();
            
            // Setup event listeners
            this.setupEventListeners();
            
            // Initialize progress tracking with error handling
            await this.initializeProgressTracking();
            
            // Auto-visual sync
            setTimeout(async () => {
                try {
                    await this.syncVisualState();
                } catch (error) {
                    console.warn('Progress sync failed:', error);
                }
            }, CCNAConfig.ui.timing.progressSync);
        } catch (error) {
            this.handleInitError(error);
        }
    }
    
    validateSectionData(data) {
        try {
            // Basic structure validation
            if (!data || typeof data !== 'object') {
                return false;
            }

            // Check for required metadata structure
            if (!data.metadata || typeof data.metadata !== 'object') {
                console.warn('Missing required property: metadata');
                return false;
            }

            // Check for subsections in metadata
            if (!data.metadata.subsections || typeof data.metadata.subsections !== 'object') {
                console.warn('Missing required property: metadata.subsections');
                return false;
            }

            // Validate at least one subsection exists
            const subsectionKeys = Object.keys(data.metadata.subsections);
            if (subsectionKeys.length === 0) {
                console.warn('At least one subsection must be defined');
                return false;
            }

            return true;
        } catch (error) {
            console.error('Error validating section data:', error);
            return false;
        }
    }
    
    handleDataError(message) {
        console.error(message);
        this.showErrorMessage(`Failed to load section data: ${message}`, true);
    }
    
    /**
     * Synchronize visual state of topic cards based on completion status
     * This replaces the DOM-dependent method in UnifiedCCNAProgressTracker
     */
    async syncVisualState() {
        if (!this.progressTracker || typeof this.progressTracker.getTopicCompletionStates !== 'function') {
            console.warn('Cannot sync visual state: progress tracker not available or missing method');
            return;
        }
        
        try {
            const completionStates = await this.progressTracker.getTopicCompletionStates();
            const completedCount = Object.values(completionStates).filter(Boolean).length;
            console.log(`🎨 Syncing visual state: ${completedCount} completed topics`);
            
            let cardsUpdated = 0;
            document.querySelectorAll('.topic-card').forEach(card => {
                const titleElement = card.querySelector('h3');
                if (titleElement) {
                    const title = titleElement.textContent.trim();
                    if (completionStates[title]) {
                        card.classList.add('studied');
                        cardsUpdated++;
                    } else {
                        card.classList.remove('studied');
                    }
                }
            });
            
            console.log(`✅ Visual state synced: ${cardsUpdated} cards marked as completed`);
        } catch (error) {
            console.error('Error syncing visual state:', error);
        }
    }
    
    handleInitError(error) {
        console.error('Section initialization failed:', error);
        this.showErrorMessage(`Section failed to initialize: ${error.message}`, true);
    }
    
    showErrorMessage(message, isPersistent = false) {
        try {
            const errorContainer = document.createElement('div');
            errorContainer.className = 'error-message bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4';
            
            // Create safe DOM structure instead of innerHTML
            const flexDiv = document.createElement('div');
            flexDiv.className = 'flex justify-between items-center';
            
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message; // Safe text content
            flexDiv.appendChild(messageSpan);
            
            if (!isPersistent) {
                const closeBtn = document.createElement('button');
                closeBtn.className = 'ml-4 text-red-500 hover:text-red-700';
                closeBtn.textContent = '×';
                closeBtn.addEventListener('click', () => errorContainer.remove());
                flexDiv.appendChild(closeBtn);
            }
            
            errorContainer.appendChild(flexDiv);
            
            // Insert at the top of the main content
            const mainContent = document.querySelector('main') || document.body;
            mainContent.insertBefore(errorContainer, mainContent.firstChild);
            
            if (!isPersistent) {
                // Auto-remove after 10 seconds
                setTimeout(() => {
                    if (errorContainer.parentNode) {
                        errorContainer.remove();
                    }
                }, 10000);
            }
        } catch (error) {
            // Fallback to console if UI error display fails
            console.error('Failed to display error message:', error);
            console.error('Original message:', message);
        }
    }
    
    createTopicCards(topics, gridElement) {
        if (!gridElement) return;
        
        topics.forEach(topic => {
            const card = CCNAConfig.createTopicCard(topic);
            const clickHandler = () => this.openStudyModal(topic, card);
            card.onclick = clickHandler;
            // Track for cleanup
            this.cardListeners.push({ element: card, handler: clickHandler });
            gridElement.appendChild(card);
        });
    }
    
    populateGrids() {
        const mainElement = document.querySelector('main');
        if (!mainElement) {
            console.error('Main element not found for populating grids');
            return;
        }

        // Clear existing content
        mainElement.innerHTML = '';

        // Create grids dynamically for each subsection
        Object.keys(this.data.metadata.subsections).forEach(key => {
            if (!this.data[key]) return;

            const subsectionInfo = this.data.metadata.subsections[key];
            
            // Create subsection container
            const sectionContainer = document.createElement('section');
            sectionContainer.className = 'subsection-container';
            
            // Create subsection header
            const header = document.createElement('h2');
            header.className = 'subsection-title';
            header.textContent = subsectionInfo.title;
            sectionContainer.appendChild(header);
            
            // Create grid container
            const gridElement = document.createElement('div');
            gridElement.id = key + 'Grid';
            gridElement.className = 'topic-grid';
            sectionContainer.appendChild(gridElement);
            
            // Add to main element
            mainElement.appendChild(sectionContainer);
            
            // Populate the grid with topic cards
            this.createTopicCards(this.data[key], gridElement);
            
            console.log(`Created and populated ${key}Grid with ${this.data[key].length} topics`);
        });
    }
    
    /**
     * Extract topic titles and provide them to the progress tracker
     * This makes SectionLoader responsible for topic extraction instead of progress tracker
     */
    provideTopicsToProgressTracker() {
        if (!this.progressTracker || !this.data) {
            console.warn('Cannot provide topics: progress tracker or data not available');
            return;
        }
        
        try {
            // Extract all topic titles from the section data
            const topicTitles = [];
            
            Object.keys(this.data.metadata.subsections).forEach(key => {
                if (this.data[key] && Array.isArray(this.data[key])) {
                    this.data[key].forEach(topic => {
                        if (topic && topic.title) {
                            topicTitles.push(topic.title);
                        }
                    });
                }
            });
            
            // Provide topics to progress tracker
            if (typeof this.progressTracker.setChapterTopics === 'function') {
                this.progressTracker.setChapterTopics(this.sectionNumber, topicTitles);
                console.log(`Provided ${topicTitles.length} topics to progress tracker for section ${this.sectionNumber}`);
            } else {
                console.warn('Progress tracker does not support setChapterTopics method');
            }
        } catch (error) {
            console.error('Error providing topics to progress tracker:', error);
        }
    }
    
    async openStudyModal(topic, cardElement) {
        this.currentTopic = topic;
        this.currentCardElement = cardElement;
        
        // Use cached DOM elements
        this.dom.modalTitle.textContent = topic.title;
        this.dom.modalDescription.textContent = topic.description || 'Click to study this topic.';
        
        if (topic.visual) {
            // Clear existing content safely
            this.dom.modalSvg.textContent = '';
            
            // Sanitize SVG content before injection (Golden Rules compliance)
            const sanitizedVisual = window.securityUtils.sanitizeHTML(topic.visual, {
                ALLOWED_TAGS: ['svg', 'g', 'rect', 'circle', 'line', 'path', 'text', 'title', 'polygon', 'polyline', 'ellipse'],
                ALLOWED_ATTR: ['viewBox', 'x', 'y', 'width', 'height', 'rx', 'ry', 'cx', 'cy', 'r', 'x1', 'y1', 'x2', 'y2', 
                              'fill', 'stroke', 'stroke-width', 'font-size', 'font-family', 'font-weight', 'text-anchor', 'd', 'points']
            });
            
            // Create a temporary container to parse sanitized SVG
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = sanitizedVisual;
            
            // Move SVG elements to the modal container
            while (tempDiv.firstChild) {
                this.dom.modalSvg.appendChild(tempDiv.firstChild);
            }
        } else {
            this.dom.modalSvg.textContent = '';
        }
        
        // Initialize button state based on completion status
        if (this.progressTracker && this.dom.markCompleted) {
            const isCompleted = cardElement && cardElement.classList.contains('studied');
            CCNAConfig.initializeButton(this.dom.markCompleted, isCompleted);
        }
        
        // Use cached elements for modal operations
        CCNAConfig.openModal(this.dom.studyModal, this.dom.modalContent);
    }
    
    closeStudyModal() {
        // Use cached DOM elements
        CCNAConfig.closeModal(this.dom.studyModal, this.dom.modalContent);
        setTimeout(() => {
            this.currentTopic = null;
        }, CCNAConfig.ui.timing.modalCleanup);
    }
    
    openDetailsModal(topic) {
        const detailsContent = CCNAConfig.loadDetailsContent(this.sectionNumber, topic.title);
        
        // Use cached DOM elements
        this.dom.detailsModalTitle.textContent = topic.title;
        
        // Strip inline styles and sanitize content for CSP compliance
        const cleanedContent = window.securityUtils.stripInlineStylesForModal(detailsContent);
        const sanitizedContent = window.securityUtils.sanitizeHTML(cleanedContent, {
            ALLOWED_TAGS: ['div', 'h3', 'h4', 'h5', 'p', 'strong', 'em', 'ul', 'ol', 'li', 'a', 'table', 'tr', 'th', 'td', 'br'],
            ALLOWED_ATTR: ['class', 'href', 'target']
        });
        
        this.dom.detailsModalBody.innerHTML = sanitizedContent;
        
        // Use cached elements for modal operations
        CCNAConfig.openDetailsModal(this.dom.detailsModal, this.dom.detailsModalContent);
    }
    
    closeDetailsModal() {
        // Use cached DOM elements
        CCNAConfig.closeDetailsModal(this.dom.detailsModal, this.dom.detailsModalContent);
    }

    async initializeProgressTracking() {
        try {
            // Wait for progress data to load from server/storage
            if (this.progressTracker && this.sectionNumber) {
                await this.progressTracker.getSectionProgress(this.sectionNumber);
                console.log('✅ Progress data loaded for section', this.sectionNumber);
            }
            
            // Subscribe to progress updates to refresh the UI
            if (this.progressTracker) {
                this.progressTracker.subscribe((eventType, data) => {
                    if (eventType === 'progress-updated') {
                        this.updateSectionProgressBar();
                        this.syncVisualState();
                    }
                });
            }
            
            // Initial update of section progress bar
            await this.updateSectionProgressBar();
            
            // Sync visual state with stored progress using SectionLoader's method
            await this.syncVisualState();
        } catch (error) {
            console.warn('Failed to initialize progress tracking:', error);
        }
    }
    
    async updateSectionProgressBar() {
        try {
            if (!this.progressTracker || !this.sectionNumber) {
                return;
            }
            
            const stats = await this.progressTracker.getSectionProgressStats(this.sectionNumber);
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            if (progressBar) {
                progressBar.style.width = `${stats.percentage}%`;
            }
            
            if (progressText) {
                progressText.textContent = `${stats.completed}/${stats.total} (${stats.percentage}%)`;
            }
            
            console.log(`📊 Section ${this.sectionNumber} progress: ${stats.completed}/${stats.total} (${stats.percentage}%)`);
        } catch (error) {
            console.error('Failed to update section progress bar:', error);
        }
    }

    setupEventListeners() {
        // Helper function to add and track listeners
        const addListener = (element, event, handler) => {
            if (typeof element === 'string') {
                const elementId = element;
                element = document.getElementById(element);
                console.log(`🎯 Adding ${event} listener to element "${elementId}":`, element);
            }
            if (element) {
                element.addEventListener(event, handler);
                this.listeners.push({ element, event, handler });
                console.log(`✅ Successfully added ${event} listener to:`, element);
            } else {
                console.error(`❌ Failed to add ${event} listener - element not found:`, element);
            }
        };

        // Study modal close functionality
        addListener('closeModal', 'click', () => this.closeStudyModal());
        addListener('studyModal', 'click', (e) => {
            if (e.target === e.currentTarget) this.closeStudyModal();
        });

        // Details button functionality
        addListener('viewDetails', 'click', () => {
            if (this.currentTopic) {
                this.openDetailsModal(this.currentTopic);
            }
        });

        // Details modal close functionality
        addListener('closeDetails', 'click', () => this.closeDetailsModal());
        addListener('detailsModal', 'click', (e) => {
            if (e.target === e.currentTarget) this.closeDetailsModal();
        });

        // Mark completed functionality
        addListener('markCompleted', 'click', async (event) => {
            console.log('🔥 MARK COMPLETED BUTTON CLICKED - EVENT HANDLER STARTED');
            console.log('Event:', event);
            console.log('Current topic:', this.currentTopic);
            console.log('Current card element:', this.currentCardElement);
            
            if (this.currentTopic && this.currentCardElement) {
                console.log('✅ Topic and card element exist, proceeding...');
                
                try {
                    const isCompleted = await this.progressTracker.isTopicCompleted(this.currentTopic.title);
                    console.log(`🔍 Topic "${this.currentTopic.title}" current state: ${isCompleted ? 'COMPLETED' : 'UNCOMPLETED'}`);
                    
                    const newState = !isCompleted;
                    console.log(`🎯 Setting topic "${this.currentTopic.title}" to: ${newState ? 'COMPLETED' : 'UNCOMPLETED'}`);
                    
                    // Call the progress tracker method
                    console.log('📞 Calling progressTracker.markTopicCompleted...');
                    await this.progressTracker.markTopicCompleted(this.currentTopic.title, newState);
                    console.log('✅ progressTracker.markTopicCompleted completed');
                    
                    // Update card visual state using global config
                    console.log('🎨 Updating card visual state...');
                    CCNAConfig.markCardAsStudied(this.currentCardElement, newState);
                    console.log('✅ Card visual state updated');
                    
                    // Update button state using cached element
                    console.log('🔘 Updating button state...');
                    CCNAConfig.applyButtonState(this.dom.markCompleted, newState);
                    console.log('✅ Button state updated');
                    
                    console.log('🚪 Closing study modal...');
                    this.closeStudyModal();
                    console.log('✅ Study modal closed');
                    
                } catch (error) {
                    console.error('❌ ERROR in mark completed handler:', error);
                }
            } else {
                console.warn('⚠️ Missing current topic or card element');
                console.log('Current topic:', this.currentTopic);
                console.log('Current card element:', this.currentCardElement);
            }
            
            console.log('🔥 MARK COMPLETED EVENT HANDLER FINISHED');
        });

        // Add keyboard support with cached elements
        const keydownHandler = (e) => {
            if (e.key === 'Escape') {
                if (CCNAConfig.isModalVisible(this.dom.detailsModal)) {
                    this.closeDetailsModal();
                } else if (CCNAConfig.isModalVisible(this.dom.studyModal)) {
                    this.closeStudyModal();
                }
            }
        };
        document.addEventListener('keydown', keydownHandler);
        this.listeners.push({ element: document, event: 'keydown', handler: keydownHandler });
    }

    /**
     * Cleanup method to prevent memory leaks
     * Removes all event listeners tracked by this instance
     */
    destroy() {
        // Remove all tracked event listeners
        this.listeners.forEach(({ element, event, handler }) => {
            if (element && element.removeEventListener) {
                element.removeEventListener(event, handler);
            }
        });
        this.listeners = [];

        // Remove card click listeners
        this.cardListeners.forEach(({ element, handler }) => {
            if (element) {
                element.onclick = null;
            }
        });
        this.cardListeners = [];

        // Clear references
        this.progressTracker = null;
        this.currentTopic = null;
        this.currentCardElement = null;
        this.data = null;
        this.dom = {}; // Clear DOM cache

        console.log(`SectionLoader ${this.sectionNumber} destroyed and cleaned up`);
    }
}

// Initialize section loader when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Section number is passed via window.SECTION_NUMBER
    // Only auto-initialize if not already manually initialized
    if (!window.sectionLoader) {
        if (typeof window.SECTION_NUMBER !== 'undefined') {
            // Support for new constructor pattern - check if data is available
            const sectionData = window[`SECTION${window.SECTION_NUMBER}_DATA`] || null;
            window.sectionLoader = new SectionLoader(window.SECTION_NUMBER, sectionData);
        } else {
            console.warn('SectionLoader not manually initialized and window.SECTION_NUMBER not defined. Skipping auto-initialization.');
        }
    }
});